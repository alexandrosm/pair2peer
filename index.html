<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pair2Peer - Compressed</title>
    <meta name="theme-color" content="#1e40af">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/jsqr@1.4.0/dist/jsQR.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
</head>
<body class="bg-gray-50 min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-md">
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h1 class="text-2xl font-bold text-center mb-2">Pair2Peer</h1>
            <p class="text-xs text-gray-500 text-center mb-4" id="version-display">v1.4.0</p>
            
            <div id="status" class="mb-4 p-3 rounded-lg bg-blue-50 text-blue-800 text-center">
                Ready to connect
            </div>
            
            <!-- Start -->
            <div id="step-start" class="step-view">
                <p class="text-gray-600 text-center mb-4">Direct P2P - No Server Needed</p>
                <div class="text-xs text-gray-500 mb-4 p-2 bg-gray-50 rounded">
                    <p class="font-semibold">Instructions:</p>
                    <p>1. Click "Device 1" on computer/first device</p>
                    <p>2. Click "Device 2" on phone/second device</p>
                    <p>3. Scan QR from Device 1 with Device 2</p>
                </div>
                <button id="device1-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg mb-2">
                    Device 1 (Start) - Shows QR
                </button>
                <button id="device2-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-4 rounded-lg mb-2">
                    Device 2 (Join) - Scans QR
                </button>
                <button id="selftest-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg text-sm">
                    Self Test (Debug)
                </button>
            </div>

            <!-- Show QR -->
            <div id="step-show" class="step-view hidden">
                <div class="text-center mb-4">
                    <p class="text-lg font-bold mb-2" id="show-title">Share this:</p>
                    <div id="qr-display" class="mx-auto mb-4 flex justify-center"></div>
                    <div class="text-xs text-gray-500 mb-2">
                        <p>QR Size: <span id="qr-size">0</span> chars</p>
                        <p>QR Bits: <span id="qr-bits">0</span> bits</p>
                        <p>Compression: <span id="compression-ratio">0</span>%</p>
                        <p>Method: ASN.1 UPER + Base64</p>
                    </div>
                    <details class="text-xs">
                        <summary class="cursor-pointer text-blue-600">Manual copy</summary>
                        <textarea id="data-text" class="w-full h-20 p-2 border rounded text-xs font-mono mt-2" readonly></textarea>
                    </details>
                </div>
                <button id="next-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg">
                    Next Step
                </button>
            </div>

            <!-- Scan QR -->
            <div id="step-scan" class="step-view hidden">
                <p class="text-center mb-4" id="scan-title">Scan QR Code:</p>
                <div class="relative bg-black rounded-lg overflow-hidden mb-4" style="aspect-ratio: 4/3;">
                    <video id="video" class="w-full h-full object-cover" autoplay playsinline></video>
                </div>
                <button id="manual-btn" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-lg">
                    Enter Manually
                </button>
            </div>

            <!-- Manual Input -->
            <div id="step-manual" class="step-view hidden">
                <p class="text-center mb-4">Paste the data:</p>
                <textarea id="manual-input" class="w-full h-32 p-2 border rounded text-xs font-mono" placeholder="Paste here..."></textarea>
                <button id="process-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg mt-2">
                    Process
                </button>
                <button id="back-scan-btn" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-lg mt-2">
                    Back to Scanner
                </button>
            </div>

            <!-- Connected -->
            <div id="step-connected" class="step-view hidden">
                <div class="text-center">
                    <svg class="w-16 h-16 text-green-600 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <h2 class="text-xl font-semibold text-gray-800 mb-2">Connected!</h2>
                    <div id="messages" class="h-40 overflow-y-auto bg-gray-100 rounded p-3 mb-4 text-sm text-left"></div>
                    <div class="flex gap-2">
                        <input id="msg-input" type="text" class="flex-1 p-2 border rounded" placeholder="Type a message...">
                        <button id="send-btn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Import functions from modules
        import { compactSDP, expandSDP } from './sdp-compact.js?v=1.2.2';
        import { encodeWebRTCData, decodeWebRTCData } from './asn1-uper-codec.js?v=1.2.0';
        
        // Version info
        const APP_VERSION = '1.3.2';
        const BUILD_DATE = new Date().toISOString();
        const GIT_COMMIT = 'c5bb36e'; // Will be updated by CI/CD
        
        console.log(`%cPair2Peer v${APP_VERSION}`, 'font-size: 16px; font-weight: bold; color: #1e40af;');
        console.log(`Build: ${BUILD_DATE}`);
        console.log(`Commit: ${GIT_COMMIT}`);
        console.log(`ASN.1 UPER codec: Direct binary output`);
        console.log('---');
        
        // Update version in UI
        document.getElementById('version-display').textContent = `v${APP_VERSION}`;
        
        const state = {
            role: null,
            pc: null,
            dc: null,
            stream: null,
            scanTarget: null,
            lastData: null,
            preGeneratedOffer: null,
            preGeneratedQR: null
        };

        // Compression utilities
        function compressData(obj) {
            // Use ASN.1 UPER encoding
            const binary = encodeWebRTCData(obj);
            console.log('ASN.1 UPER encoded to', binary.length, 'bytes');
            
            // Convert binary to string for QR code
            // Using Latin-1 encoding to preserve all byte values
            let binaryStr = '';
            for (let i = 0; i < binary.length; i++) {
                binaryStr += String.fromCharCode(binary[i]);
            }
            return btoa(binaryStr); // Base64 for safe transport
        }

        function decompressData(str) {
            try {
                console.log('Decompressing string:', str.substring(0, 50) + '...');
                
                // Decode from Base64
                const binaryStr = atob(str);
                const bytes = new Uint8Array(binaryStr.length);
                for (let i = 0; i < binaryStr.length; i++) {
                    bytes[i] = binaryStr.charCodeAt(i);
                }
                console.log('Decoded to', bytes.length, 'bytes');
                console.log('First 10 bytes:', Array.from(bytes.slice(0, 10)));
                
                // Decode ASN.1 UPER format
                const decoded = decodeWebRTCData(bytes);
                console.log('ASN.1 UPER decoded:', decoded);
                
                return decoded;
            } catch (error) {
                console.error('Decompression error:', error);
                console.error('Error stack:', error.stack);
                return null;
            }
        }

        // Extract only essential SDP data (including bundled ICE candidates)
        function minimizeSDP(sdp) {
            const lines = sdp.split('\n');
            const essential = [];
            
            lines.forEach(line => {
                // Keep only essential lines
                if (line.startsWith('v=') || 
                    line.startsWith('o=') ||
                    line.startsWith('s=') ||
                    line.startsWith('t=') ||
                    line.startsWith('a=group:') ||
                    line.startsWith('a=msid-semantic:') ||
                    line.startsWith('m=') ||
                    line.includes('a=ice-ufrag:') ||
                    line.includes('a=ice-pwd:') ||
                    line.includes('a=fingerprint:') ||
                    line.includes('a=setup:') ||
                    line.includes('a=mid:') ||
                    line.includes('a=sendrecv') ||
                    line.includes('a=rtcp-mux') ||
                    line.includes('a=candidate:') ||
                    line.includes('a=end-of-candidates')) {
                    essential.push(line);
                }
            });
            
            return essential.join('\n');
        }

        function showStep(step) {
            document.querySelectorAll('.step-view').forEach(el => el.classList.add('hidden'));
            document.getElementById(`step-${step}`).classList.remove('hidden');
        }

        function updateStatus(msg, type = 'info') {
            const el = document.getElementById('status');
            el.textContent = msg;
            const colorClasses = 
                type === 'error' ? 'bg-red-50 text-red-800' :
                type === 'success' ? 'bg-green-50 text-green-800' :
                'bg-blue-50 text-blue-800';
            el.className = 'mb-4 p-3 rounded-lg text-center ' + colorClasses;
        }

        async function startDevice1() {
            state.role = 'device1';
            updateStatus('Creating connection...');
            
            try {
                state.pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                state.dc = state.pc.createDataChannel('chat', {
                    ordered: true,
                    maxRetransmits: 3
                });
                setupDataChannel();
                
                // Create offer
                const offer = await state.pc.createOffer();
                await state.pc.setLocalDescription(offer);
                
                // Wait for ICE gathering to complete
                await new Promise((resolve) => {
                    if (state.pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        state.pc.onicegatheringstatechange = () => {
                            if (state.pc.iceGatheringState === 'complete') {
                                resolve();
                            }
                        };
                        setTimeout(resolve, 3000); // Max 3 seconds
                    }
                });
                
                // Create ultra-compact offer data
                const offerData = {
                    t: 'o', // type: offer
                    ...compactSDP(state.pc.localDescription.sdp)
                };
                
                // Store for stats
                state.lastData = offerData;
                console.log('Offer data:', offerData);
                console.log('Offer type check: t =', offerData.t, '(should be "o")');
                console.log('Fingerprint length:', offerData.f ? offerData.f.length : 0);
                
                // Debug candidates
                if (offerData.c && offerData.c.length > 0) {
                    console.log('Candidates:');
                    offerData.c.forEach((cand, idx) => {
                        console.log(`  ${idx}: ${cand}`);
                        const parts = cand.split(',');
                        if (parts[1]) {
                            const [ip, port] = parts[1].split(':');
                            console.log(`    IP: ${ip}, Port: ${port}, Port int: ${parseInt(port)}`);
                        }
                    });
                }
                
                // Compress and show
                const compressed = compressData(offerData);
                console.log('Compressed offer:', compressed);
                console.log('Compressed length:', compressed.length);
                
                // Test decode immediately
                const testDecode = decompressData(compressed);
                console.log('Test decode result:', testDecode);
                console.log('Test decode type:', testDecode?.t);
                
                // Debug decoded candidates
                if (testDecode?.c && testDecode.c.length > 0) {
                    console.log('Decoded candidates:');
                    testDecode.c.forEach((cand, idx) => {
                        console.log(`  ${idx}: ${cand}`);
                        const parts = cand.split(',');
                        if (parts[1]) {
                            const [ip, port] = parts[1].split(':');
                            console.log(`    IP: ${ip}, Port: ${port}, Port int: ${parseInt(port)}`);
                        }
                    });
                }
                
                showQR(compressed, 'Step 1: Show to Device 2');
                
            } catch (error) {
                updateStatus('Error: ' + error.message, 'error');
            }
        }

        async function processOffer(compressedData) {
            try {
                console.log('Processing compressed data:', compressedData);
                console.log('Compressed data length:', compressedData.length);
                
                const data = decompressData(compressedData);
                console.log('Decompressed offer data:', data);
                
                if (!data) {
                    throw new Error('Decompression failed - returned null');
                }
                if (data.t !== 'o') {
                    if (data.t === 'a') {
                        throw new Error('Received an answer instead of offer. Make sure to click Device 1 first, then Device 2.');
                    }
                    throw new Error(`Invalid offer type: expected 'o', got '${data.t}'`);
                }
                
                updateStatus('Processing offer...');
                state.role = 'device2';
                
                state.pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                state.pc.ondatachannel = (event) => {
                    state.dc = event.channel;
                    setupDataChannel();
                };
                
                // Set remote description (expand from compact format)
                const expandedSDP = expandSDP(data, 'offer');
                console.log('Expanded SDP:', expandedSDP);
                
                // Check if the problematic line exists
                if (expandedSDP.includes('a=end-of-candidates')) {
                    console.error('WARNING: SDP contains end-of-candidates line!');
                }
                
                try {
                    await state.pc.setRemoteDescription({
                        type: 'offer',
                        sdp: expandedSDP
                    });
                } catch (sdpError) {
                    console.error('SDP Error:', sdpError);
                    console.error('Full SDP was:', expandedSDP);
                    throw sdpError;
                }
                
                // ICE candidates are now bundled in the SDP
                
                // Create answer
                const answer = await state.pc.createAnswer();
                await state.pc.setLocalDescription(answer);
                
                // Wait for ICE gathering to complete
                await new Promise((resolve) => {
                    if (state.pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        state.pc.onicegatheringstatechange = () => {
                            if (state.pc.iceGatheringState === 'complete') {
                                resolve();
                            }
                        };
                        setTimeout(resolve, 3000);
                    }
                });
                
                // Create ultra-compact answer data
                const answerData = {
                    t: 'a', // type: answer
                    ...compactSDP(state.pc.localDescription.sdp)
                };
                
                console.log('Creating answer data:', answerData);
                console.log('Answer type:', answerData.t);
                
                // Store for stats
                state.lastData = answerData;
                
                // Compress and show
                const compressed = compressData(answerData);
                showQR(compressed, 'Step 2: Show to Device 1');
                
            } catch (error) {
                updateStatus('Error: ' + error.message, 'error');
            }
        }

        async function processAnswer(compressedData) {
            try {
                const data = decompressData(compressedData);
                if (!data || data.t !== 'a') throw new Error('Invalid answer');
                
                updateStatus('Connecting...');
                
                // Set remote description (expand from compact format)
                const expandedSDP = expandSDP(data, 'answer');
                await state.pc.setRemoteDescription({
                    type: 'answer',
                    sdp: expandedSDP
                });
                
                // ICE candidates are now bundled in the SDP
                
            } catch (error) {
                updateStatus('Error: ' + error.message, 'error');
            }
        }

        function showQR(data, title) {
            document.getElementById('show-title').textContent = title;
            document.getElementById('data-text').value = data;
            
            // Calculate stats
            const originalJson = JSON.stringify({
                type: state.lastData.t === 'o' ? 'offer' : 'answer',
                sdp: 'v=0\no=- 1 1 IN IP4 127.0.0.1\ns=-\nt=0 0\n...(~1KB of SDP)...',
                candidates: ['candidate:...', 'candidate:...', 'candidate:...']
            });
            const binarySize = encodeWebRTCData(state.lastData || {}).length;
            const qrSize = data.length;
            const qrBits = Math.ceil(qrSize * 8); // Base64 uses 8 bits per char in QR
            
            document.getElementById('qr-size').textContent = `${qrSize} (${binarySize} bytes UPER)`;
            document.getElementById('qr-bits').textContent = qrBits;
            document.getElementById('compression-ratio').textContent = 
                Math.round((1 - qrBits / 7744) * 100); // vs original ~1KB
            
            // Generate QR
            const qrDiv = document.getElementById('qr-display');
            qrDiv.innerHTML = '';
            
            try {
                new QRCode(qrDiv, {
                    text: data,
                    width: 256,
                    height: 256,
                    correctLevel: QRCode.CorrectLevel.L
                });
            } catch (error) {
                // If QR is too big, show error
                qrDiv.innerHTML = '<p class="text-red-600">Data too large for QR. Use manual copy.</p>';
            }
            
            showStep('show');
            updateStatus(title);
        }

        function setupDataChannel() {
            state.dc.onopen = () => {
                showStep('connected');
                updateStatus('Connected!', 'success');
                stopCamera();
            };
            
            state.dc.onmessage = (e) => {
                addMessage('Them', e.data);
            };
            
            state.dc.onerror = (error) => {
                updateStatus('Connection error', 'error');
                console.error('DataChannel error:', error);
            };
        }

        function addMessage(sender, text) {
            const el = document.getElementById('messages');
            const msg = document.createElement('div');
            msg.className = sender === 'You' ? 'text-right mb-1' : 'text-left mb-1';
            msg.innerHTML = `<span class="font-semibold">${sender}:</span> ${text}`;
            el.appendChild(msg);
            el.scrollTop = el.scrollHeight;
        }

        async function startScanner() {
            try {
                state.stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                
                const video = document.getElementById('video');
                video.srcObject = state.stream;
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                const scan = () => {
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        ctx.drawImage(video, 0, 0);
                        
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height);
                        
                        if (code) {
                            stopCamera();
                            if (state.scanTarget === 'offer') {
                                processOffer(code.data);
                            } else {
                                processAnswer(code.data);
                            }
                            return;
                        }
                    }
                    if (state.stream) requestAnimationFrame(scan);
                };
                
                video.addEventListener('loadedmetadata', scan);
                
            } catch (error) {
                updateStatus('Camera error', 'error');
                showStep('manual');
            }
        }

        function stopCamera() {
            if (state.stream) {
                state.stream.getTracks().forEach(t => t.stop());
                state.stream = null;
            }
        }

        // Event listeners
        document.getElementById('device1-btn').addEventListener('click', startDevice1);
        
        document.getElementById('device2-btn').addEventListener('click', () => {
            state.scanTarget = 'offer';
            document.getElementById('scan-title').textContent = 'Scan offer from Device 1:';
            showStep('scan');
            startScanner();
        });
        
        document.getElementById('next-btn').addEventListener('click', () => {
            if (state.role === 'device1') {
                state.scanTarget = 'answer';
                document.getElementById('scan-title').textContent = 'Scan answer from Device 2:';
                showStep('scan');
                startScanner();
            } else {
                showStep('connected');
            }
        });
        
        document.getElementById('manual-btn').addEventListener('click', () => {
            stopCamera();
            showStep('manual');
        });
        
        document.getElementById('process-btn').addEventListener('click', () => {
            const data = document.getElementById('manual-input').value.trim();
            if (data) {
                if (state.scanTarget === 'offer') {
                    processOffer(data);
                } else {
                    processAnswer(data);
                }
            }
        });
        
        document.getElementById('back-scan-btn').addEventListener('click', () => {
            document.getElementById('manual-input').value = '';
            showStep('scan');
            startScanner();
        });
        
        document.getElementById('send-btn').addEventListener('click', () => {
            const input = document.getElementById('msg-input');
            if (input.value && state.dc?.readyState === 'open') {
                state.dc.send(input.value);
                addMessage('You', input.value);
                input.value = '';
            }
        });
        
        document.getElementById('msg-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') document.getElementById('send-btn').click();
        });
        
        // Pre-generate offer on load for instant QR display
        async function preGenerateOffer() {
            try {
                console.log('Pre-generating offer...');
                const pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                const dc = pc.createDataChannel('data');
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                // Wait for ICE gathering
                await new Promise((resolve) => {
                    if (pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        pc.addEventListener('icegatheringstatechange', () => {
                            if (pc.iceGatheringState === 'complete') resolve();
                        });
                        setTimeout(resolve, 3000); // Max 3 seconds
                    }
                });
                
                // Create compact offer data
                const offerData = {
                    t: 'o',
                    ...compactSDP(pc.localDescription.sdp)
                };
                
                console.log('Pre-generation: offerData candidates:', offerData.c ? offerData.c.length : 0);
                if (offerData.c) {
                    offerData.c.forEach((cand, idx) => {
                        console.log(`  Pre-gen candidate ${idx + 1}: ${cand}`);
                    });
                }
                
                // Compress and store
                state.preGeneratedOffer = offerData;
                state.preGeneratedQR = compressData(offerData);
                
                // Clean up
                pc.close();
                
                console.log('Pre-generated QR ready:', state.preGeneratedQR.length, 'chars');
            } catch (error) {
                console.error('Pre-generation failed:', error);
            }
        }
        
        // Pre-generate on load
        preGenerateOffer();
        
        // Self-test function
        async function runSelfTest() {
            console.log('=== RUNNING SELF TEST ===');
            updateStatus('Running self test...', 'info');
            
            try {
                // Wait for pre-generation to complete if not ready
                if (!state.preGeneratedOffer || !state.preGeneratedQR) {
                    console.log('Waiting for pre-generation to complete...');
                    let waitCount = 0;
                    while ((!state.preGeneratedOffer || !state.preGeneratedQR) && waitCount < 50) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        waitCount++;
                    }
                    
                    if (!state.preGeneratedOffer || !state.preGeneratedQR) {
                        console.log('Pre-generation did not complete in time, running it now...');
                        await preGenerateOffer();
                    }
                }
                
                // Test 1: Use the ACTUAL pre-generated offer
                if (state.preGeneratedOffer && state.preGeneratedQR) {
                    console.log('\n--- TEST 1: Real WebRTC Offer ---');
                    console.log('Using actual pre-generated offer');
                    console.log('Original offer:', state.preGeneratedOffer);
                    console.log('Original offer candidates count:', state.preGeneratedOffer.c ? state.preGeneratedOffer.c.length : 0);
                    if (state.preGeneratedOffer.c) {
                        state.preGeneratedOffer.c.forEach((cand, idx) => {
                            console.log(`  Candidate ${idx + 1}: ${cand}`);
                        });
                    }
                    console.log('Compressed QR:', state.preGeneratedQR);
                    console.log('QR length:', state.preGeneratedQR.length, 'characters');
                    
                    // Simulate what Device 2 would do
                    const simulatedScan = state.preGeneratedQR;
                    console.log('Simulating QR scan of:', simulatedScan.substring(0, 50) + '...');
                    
                    // Log the binary data
                    const binaryStr = atob(simulatedScan);
                    const bytes = new Uint8Array(binaryStr.length);
                    for (let i = 0; i < binaryStr.length; i++) {
                        bytes[i] = binaryStr.charCodeAt(i);
                    }
                    console.log('Binary data length:', bytes.length, 'bytes');
                    console.log('Binary hex:', Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' '));
                    
                    const decoded = decompressData(simulatedScan);
                    console.log('Decoded result:', decoded);
                    console.log('Decoded candidates count:', decoded?.c?.length);
                    
                    if (!decoded) {
                        console.error('❌ REAL DATA TEST FAILED: Decompression returned null');
                        updateStatus('Self test failed: Real data decompression failed', 'error');
                        return;
                    }
                    
                    if (decoded.t !== 'o') {
                        console.error(`❌ REAL DATA TEST FAILED: Expected type 'o', got '${decoded.t}'`);
                        updateStatus(`Self test failed: Wrong type ${decoded.t}`, 'error');
                        return;
                    }
                    
                    // Verify all fields match
                    console.log('Comparing fields:');
                    console.log('Type match:', decoded.t === state.preGeneratedOffer.t);
                    console.log('Ufrag match:', decoded.u === state.preGeneratedOffer.u);
                    console.log('Pwd match:', decoded.p === state.preGeneratedOffer.p);
                    console.log('Setup match:', decoded.s === state.preGeneratedOffer.s);
                    console.log('Fingerprint match:', decoded.f === state.preGeneratedOffer.f);
                    console.log('Candidates match:', JSON.stringify(decoded.c) === JSON.stringify(state.preGeneratedOffer.c));
                    
                    // Test SDP expansion
                    try {
                        const expandedSDP = expandSDP(decoded, 'offer');
                        console.log('Expanded SDP length:', expandedSDP.length);
                        console.log('SDP preview:', expandedSDP.substring(0, 200) + '...');
                        
                        // Check for the problematic line from the error
                        const lines = expandedSDP.split(/\r\n|\r|\n/);
                        const candidateLines = lines.filter(l => l.startsWith('a=candidate:'));
                        console.log('Number of candidate lines:', candidateLines.length);
                        console.log('Candidate lines:', candidateLines);
                        
                        // Check for known problematic lines
                        const problematicLines = lines.filter(line => 
                            line.includes('a=max-message-size') || 
                            line.includes('a=end-of-candidates')
                        );
                        if (problematicLines.length > 0) {
                            console.error('❌ Found problematic SDP lines:', problematicLines);
                        }
                        
                        // Validate each candidate
                        let hasInvalidPort = false;
                        candidateLines.forEach((line, idx) => {
                            const portMatch = line.match(/ (\d+) typ /);
                            if (portMatch) {
                                const port = parseInt(portMatch[1]);
                                console.log(`Candidate ${idx + 1} port: ${port}`);
                                if (port < 1 || port > 65535) {
                                    console.error(`❌ Invalid port number: ${port}`);
                                    hasInvalidPort = true;
                                }
                            }
                        });
                        
                        if (hasInvalidPort) {
                            console.error('❌ REAL DATA TEST FAILED: Invalid port numbers detected');
                            updateStatus('Self test failed: Invalid port numbers', 'error');
                            return;
                        }
                        
                        // CRITICAL: Test actual browser SDP parsing
                        console.log('\nTesting browser SDP parsing...');
                        const testPc = new RTCPeerConnection();
                        try {
                            await testPc.setRemoteDescription({
                                type: 'offer',
                                sdp: expandedSDP
                            });
                            console.log('✅ Browser successfully parsed the SDP');
                            testPc.close();
                        } catch (browserError) {
                            console.error('❌ BROWSER SDP PARSING FAILED:', browserError);
                            console.error('Failed SDP was:', expandedSDP);
                            testPc.close();
                            updateStatus('Self test failed: Browser cannot parse SDP', 'error');
                            return;
                        }
                        
                        console.log('✅ REAL DATA TEST PASSED');
                    } catch (sdpError) {
                        console.error('❌ SDP expansion failed:', sdpError);
                        updateStatus('Self test failed: SDP expansion error', 'error');
                        return;
                    }
                } else {
                    console.log('❌ Real data test: Skipped (no data available)');
                }
                
                // Test 2: Simple known data
                console.log('\n--- TEST 2: Simple Known Data ---');
                const testData = {
                    t: 'o',
                    u: 'TEST',
                    p: 'TestPassword123456789012',
                    f: '01:23:45:67:89:AB:CD:EF:01:23:45:67:89:AB:CD:EF:01:23:45:67:89:AB:CD:EF:01:23:45:67:89:AB:CD:EF',
                    s: 'a',
                    c: ['h,192.168.1.100:12345', 's,10.0.0.1:54321,203.0.113.1:3478']
                };
                
                console.log('Test data:', testData);
                
                // Compress it
                const compressed = compressData(testData);
                console.log('Compressed:', compressed);
                console.log('Compressed length:', compressed.length, 'chars');
                console.log('Binary size:', encodeWebRTCData(testData).length, 'bytes');
                
                // Decompress it
                const decompressed = decompressData(compressed);
                console.log('Decompressed:', decompressed);
                
                // Verify
                const expectedFingerprint = testData.f.toUpperCase();
                const actualFingerprint = decompressed ? decompressed.f : '';
                const fingerprintMatch = actualFingerprint === expectedFingerprint;
                
                console.log('Fingerprint comparison:');
                console.log('Expected:', expectedFingerprint);
                console.log('Actual:', actualFingerprint);
                console.log('Match:', fingerprintMatch);
                
                const passed = 
                    decompressed && 
                    decompressed.t === testData.t &&
                    decompressed.u === testData.u &&
                    decompressed.p === testData.p &&
                    fingerprintMatch &&
                    decompressed.s === testData.s &&
                    JSON.stringify(decompressed.c) === JSON.stringify(testData.c);
                
                if (passed) {
                    console.log('✅ SIMPLE DATA TEST PASSED');
                    
                    // Test SDP expansion
                    console.log('\nTesting SDP expansion...');
                    const expandedSDP = expandSDP(decompressed, 'offer');
                    console.log('Expanded SDP preview:', expandedSDP.substring(0, 200) + '...');
                    
                    if (expandedSDP.includes('v=0') && expandedSDP.includes('a=ice-ufrag:TEST')) {
                        console.log('✅ SDP expansion working');
                        updateStatus('Self test passed! All tests successful.', 'success');
                    } else {
                        console.log('❌ SDP expansion failed');
                        updateStatus('Self test failed: SDP expansion issue', 'error');
                    }
                } else {
                    console.log('❌ SIMPLE DATA TEST FAILED');
                    console.log('Expected:', testData);
                    console.log('Got:', decompressed);
                    updateStatus('Self test failed! Check console for details.', 'error');
                }
                
                // Summary
                console.log('\n=== TEST SUMMARY ===');
                console.log('Real data test:', state.preGeneratedOffer ? 'Passed' : 'Skipped (no data)');
                console.log('Simple data test:', passed ? 'Passed' : 'Failed');
                
            } catch (error) {
                console.error('Self test error:', error);
                updateStatus('Self test error: ' + error.message, 'error');
            }
        }
        
        // Add event listeners (only add selftest, others already exist)
        document.getElementById('selftest-btn').addEventListener('click', runSelfTest);
    </script>
</body>
</html>