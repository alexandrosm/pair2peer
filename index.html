<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pair2Peer - Compressed</title>
    <meta name="theme-color" content="#1e40af">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="version" content="2.2.4">
    <link rel="manifest" href="./manifest.json">
    <link rel="icon" href="./favicon.ico" type="image/x-icon">
    <!-- Using Tailwind CDN for rapid prototyping. For production, consider building CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/jsqr@1.4.0/dist/jsQR.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
</head>
<body class="bg-black text-gray-100 min-h-screen p-4">
    <div class="w-full max-w-md mx-auto">
        <!-- Main container with flexible height -->
        <div class="bg-black rounded-lg shadow-lg p-4">
            
            <!-- Auto-starts, no UI needed -->
            <div id="step-start" class="step-view hidden">
            </div>

            <!-- Removed Show QR step - using split view directly -->

            <!-- Split View: QR + Camera (used by both devices) -->
            <div id="step-device1-split" class="step-view hidden">
                <!-- QR Code at very top -->
                <div class="mb-3">
                    <div id="qr-display-split" class="mx-auto mb-2 flex justify-center"></div>
                </div>
                
                <!-- All UI elements moved below QR -->
                <div class="text-center mb-3">
                    <h1 class="text-2xl font-bold">Pair2Peer</h1>
                    <p class="text-xs text-gray-400" id="version-display-split">Loading...</p>
                    <p class="text-sm text-gray-400 mt-2" id="qr-type-label">Show your QR</p>
                    <div id="status" class="mt-2 p-2 rounded-lg bg-gray-900 text-gray-100 text-center text-sm">
                        Starting camera...
                    </div>
                    <!-- Debug toggle -->
                    <button id="debug-toggle-split" class="text-xs text-gray-400 hover:text-gray-200 mt-2">
                        â–¶ Debug
                    </button>
                    <div id="debug-options-split" class="mt-2">
                        <button id="selftest-btn-split" class="text-xs bg-gray-800 hover:bg-gray-700 text-white px-2 py-1 rounded mr-2">
                            Test
                        </button>
                        <button id="toggle-console-split" class="text-xs bg-gray-800 hover:bg-gray-700 text-white px-2 py-1 rounded">
                            Console
                        </button>
                    </div>
                </div>
                
                <!-- Camera Section -->
                <div class="mb-3">
                    <div class="relative bg-black rounded-lg overflow-hidden" style="aspect-ratio: 4/3;">
                        <video id="video-split" class="w-full h-full object-cover" autoplay playsinline></video>
                        <button id="switch-camera-split" class="absolute top-2 right-2 bg-gray-800 bg-opacity-80 hover:bg-opacity-100 p-2 rounded-lg shadow-lg text-gray-100" title="Switch camera">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M11 19H4a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h5"></path>
                                <path d="M13 5h7a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-5"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                                <path d="m18 22-3-3 3-3"></path>
                                <path d="m6 2 3 3-3 3"></path>
                            </svg>
                        </button>
                    </div>
                    <p class="text-center text-sm text-gray-400 mt-1">Scan their QR</p>
                </div>
                
                <!-- Debug QR info -->
                <div id="qr-debug-info" class="hidden mt-2 p-2 bg-gray-900 rounded text-xs text-gray-300">
                    <p class="font-semibold mb-1">QR Debug Info:</p>
                    <div id="qr-debug-content" class="font-mono"></div>
                </div>
            </div>

            <!-- Scan QR -->
            <div id="step-scan" class="step-view hidden">
                <p class="text-center mb-4" id="scan-title">Scan QR Code:</p>
                <div class="relative bg-black rounded-lg overflow-hidden mb-4" style="aspect-ratio: 4/3;">
                    <video id="video" class="w-full h-full object-cover" autoplay playsinline></video>
                    <button id="switch-camera-btn" class="absolute top-2 right-2 bg-gray-800 bg-opacity-80 hover:bg-opacity-100 p-2 rounded-lg shadow-lg text-gray-100" title="Switch camera">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M11 19H4a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h5"></path>
                            <path d="M13 5h7a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-5"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="m18 22-3-3 3-3"></path>
                            <path d="m6 2 3 3-3 3"></path>
                        </svg>
                    </button>
                </div>
                <button id="manual-btn" class="w-full bg-gray-800 hover:bg-gray-700 text-gray-100 font-semibold py-2 px-4 rounded-lg">
                    Enter Manually
                </button>
            </div>

            <!-- Manual Input -->
            <div id="step-manual" class="step-view hidden">
                <p class="text-center mb-4">Paste the data:</p>
                <textarea id="manual-input" class="w-full h-32 p-2 border border-gray-600 bg-gray-800 text-gray-100 rounded text-xs font-mono" placeholder="Paste here..."></textarea>
                <button id="process-btn" class="w-full bg-blue-800 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg mt-2">
                    Process
                </button>
                <button id="back-scan-btn" class="w-full bg-gray-800 hover:bg-gray-700 text-gray-100 font-semibold py-2 px-4 rounded-lg mt-2">
                    Back to Scanner
                </button>
            </div>

            <!-- Connected -->
            <div id="step-connected" class="step-view hidden">
                <div class="text-center">
                    <svg class="w-16 h-16 text-green-500 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <h2 class="text-xl font-semibold text-gray-100 mb-2">Connected!</h2>
                    
                    <!-- Network Diagnostics -->
                    <div id="network-diagnostics" class="mb-4 p-3 bg-gray-900 rounded-lg text-sm text-left">
                        <div class="font-semibold mb-2 flex items-center justify-between">
                            <span>Network Information</span>
                            <button id="refresh-diagnostics" class="text-xs bg-blue-800 hover:bg-blue-700 text-white px-2 py-1 rounded">
                                Refresh
                            </button>
                        </div>
                        <div id="diagnostics-content" class="text-xs space-y-1">
                            <div class="flex justify-between">
                                <span class="text-gray-400">Analyzing connection...</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Tab buttons -->
                    <div class="flex mb-4 border-b">
                        <button id="chat-tab" class="flex-1 py-2 px-4 border-b-2 border-gray-500 text-gray-400 font-semibold">Chat</button>
                        <button id="canvas-tab" class="flex-1 py-2 px-4 border-b-2 border-transparent hover:border-gray-500 text-gray-300">Shared Canvas</button>
                    </div>
                    
                    <!-- Chat View -->
                    <div id="chat-view" class="tab-content">
                        <div id="messages" class="h-40 overflow-y-auto bg-gray-900 rounded p-3 mb-4 text-sm text-left"></div>
                        <div class="flex gap-2">
                            <input id="msg-input" type="text" class="flex-1 p-2 border border-gray-600 bg-gray-800 text-gray-100 rounded" placeholder="Type a message...">
                            <button id="send-btn" class="bg-blue-800 hover:bg-blue-700 text-white px-4 py-2 rounded">Send</button>
                        </div>
                    </div>
                    
                    <!-- Canvas View -->
                    <div id="canvas-view" class="tab-content hidden">
                        <div class="mb-2">
                            <div class="flex gap-2 justify-center mb-2">
                                <button id="color-black" class="w-8 h-8 bg-black rounded border-2 border-gray-300" data-color="#000000"></button>
                                <button id="color-red" class="w-8 h-8 bg-red-500 rounded border-2 border-gray-300" data-color="#ef4444"></button>
                                <button id="color-blue" class="w-8 h-8 bg-blue-500 rounded border-2 border-gray-300" data-color="#3b82f6"></button>
                                <button id="color-green" class="w-8 h-8 bg-green-500 rounded border-2 border-gray-300" data-color="#10b981"></button>
                                <button id="clear-canvas" class="px-3 py-1 bg-gray-800 hover:bg-gray-700 text-gray-100 rounded text-sm">Clear</button>
                            </div>
                        </div>
                        <canvas id="shared-canvas" class="border border-gray-600 rounded bg-white cursor-crosshair" width="400" height="300"></canvas>
                        <p class="text-xs text-gray-400 mt-2">Draw on the canvas - changes sync in real-time!</p>
                    </div>
                </div>
            </div>
        </div>
        
        </div>
        
        <!-- Debug Panel - Hidden by default -->
        <div id="debug-panel" class="mt-4 bg-black text-green-400 rounded-lg p-4 font-mono text-xs overflow-auto max-h-64 hidden">
            <div class="flex justify-between items-center mb-2">
                <span class="text-white font-bold">Debug Console</span>
                <div class="space-x-2">
                    <button id="copy-debug" class="text-gray-400 hover:text-gray-300">Copy</button>
                    <button id="clear-debug" class="text-red-400 hover:text-red-300">Clear</button>
                </div>
            </div>
            <div id="debug-content"></div>
        </div>
    </div>

    <script>
        // Debug logging system for mobile - MUST be before module imports
        window.debugLogs = [];
        window.maxDebugLogs = 100;
        
        // Initialize state early for debug panel
        window.state = {
            role: null,
            pc: null,
            dc: null,
            stream: null,
            scanTarget: null,
            lastData: null,
            preGeneratedOffer: null,
            preGeneratedQR: null,
            cameraFacing: 'user', // 'user' for selfie cam, 'environment' for back
            eventHistory: [], // Track all events with timestamps
            peerEventHistory: null // Will store peer's event history after connection
        };
        
        // Debug console is off by default
        window.debugConsoleEnabled = false;
        
        window.addDebugLog = function(message, type = 'log') {
            const timestamp = new Date().toLocaleTimeString();
            const fullTimestamp = new Date().toISOString();
            window.debugLogs.push({ timestamp, message, type });
            if (window.debugLogs.length > window.maxDebugLogs) {
                window.debugLogs.shift();
            }
            
            // Also add to event history with full timestamp
            window.state.eventHistory.push({
                timestamp: fullTimestamp,
                role: window.state.role || 'unknown',
                type: type,
                message: message,
                connectionState: window.state.pc?.connectionState || 'none',
                iceState: window.state.pc?.iceConnectionState || 'none'
            });
            
            window.updateDebugPanel();
        }
        
        window.updateDebugPanel = function() {
            const panel = document.getElementById('debug-panel');
            const content = document.getElementById('debug-content');
            if (panel && content) {
                // Show panel on mobile devices if debug is enabled
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if ((isMobile || window.state.role === 'device2') && window.debugConsoleEnabled) {
                    panel.classList.remove('hidden');
                }
                
                content.innerHTML = window.debugLogs.map(log => {
                    const color = log.type === 'error' ? 'text-red-400' : 
                                 log.type === 'warn' ? 'text-yellow-400' : 'text-green-400';
                    return `<div class="${color}">[${log.timestamp}] ${log.message}</div>`;
                }).join('');
                
                // Auto-scroll to bottom
                content.scrollTop = content.scrollHeight;
            }
        }
        
        // Override console methods to capture logs
        const originalConsole = {
            log: console.log,
            error: console.error,
            warn: console.warn
        };
        
        console.log = function(...args) {
            originalConsole.log.apply(console, args);
            window.addDebugLog(args.map(arg => 
                typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
            ).join(' '), 'log');
        };
        
        console.error = function(...args) {
            originalConsole.error.apply(console, args);
            window.addDebugLog(args.map(arg => 
                typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
            ).join(' '), 'error');
        };
        
        console.warn = function(...args) {
            // Filter out known performance warnings
            if (args[0] && typeof args[0] === 'string' && 
                args[0].includes("'requestAnimationFrame' handler took")) {
                return; // Skip these warnings
            }
            originalConsole.warn.apply(console, args);
            window.addDebugLog(args.map(arg => 
                typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
            ).join(' '), 'warn');
        };
    </script>
    
    <script type="module">
        // Import version info
        import { VERSION, BUILD_DATE, GIT_COMMIT, CACHE_VERSION } from './version.js';
        
        // Use window.state instead of const state
        const state = window.state;
        
        // Import functions from modules with dynamic version
        const sdpModule = await import(`./sdp-compact.js?v=${CACHE_VERSION}`);
        const asn1Module = await import(`./asn1-uper-codec.js?v=${CACHE_VERSION}`);
        const crcModule = await import(`./crc.js?v=${CACHE_VERSION}`);
        
        const { compactSDP, expandSDP } = sdpModule;
        const { encodeWebRTCData, decodeWebRTCData } = asn1Module;
        const { addCRC, verifyCRC } = crcModule;
        
        // Simple shared state implementation
        let sharedState = {
            canvas: {
                strokes: []
            },
            lastUpdate: 0
        };
        
        // Register service worker for offline support and updates
        if ('serviceWorker' in navigator) {
            // Unregister any existing service workers first to ensure clean update
            navigator.serviceWorker.getRegistrations().then(registrations => {
                const oldWorkers = registrations.filter(reg => 
                    reg.scope === location.origin + '/pair2peer/' && 
                    reg.active && 
                    !reg.active.scriptURL.includes('v=')
                );
                
                if (oldWorkers.length > 0) {
                    console.log('Found old service workers, updating...');
                }
            });
            
            // Register with cache-busting to ensure updates
            navigator.serviceWorker.register(`./sw.js?v=${VERSION}`, {
                updateViaCache: 'none' // Force byte-by-byte comparison
            })
                .then(registration => {
                    console.log('Service Worker registered:', registration.scope);
                    
                    // Check for updates immediately
                    registration.update();
                    
                    // Check for updates on visibility change
                    document.addEventListener('visibilitychange', () => {
                        if (!document.hidden) {
                            registration.update().catch(() => {});
                        }
                    });
                    
                    // Listen for updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        if (newWorker) {
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New version available
                                    console.log('New version available - reloading...');
                                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                                    setTimeout(() => window.location.reload(), 100);
                                }
                            });
                        }
                    });
                })
                .catch(error => {
                    console.error('Service Worker registration failed:', error);
                    // Continue without service worker
                });
                
            // Listen for controller change
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                window.location.reload();
            });
        }
        
        console.log(`%cPair2Peer v${VERSION}`, 'font-size: 16px; font-weight: bold; color: #1e40af;');
        console.log(`Build: ${BUILD_DATE}`);
        console.log(`Commit: ${GIT_COMMIT}`);
        console.log(`ASN.1 UPER codec: Direct binary output`);
        console.log('---');
        
        // Helper function to format time ago
        function timeAgo(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const seconds = Math.floor((now - date) / 1000);
            
            if (seconds < 60) return `${seconds}s ago`;
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }
        
        // Update version in UI
        // Update version display in split view
        const versionSplit = document.getElementById('version-display-split');
        if (versionSplit) {
            versionSplit.textContent = `v${VERSION} (${timeAgo(BUILD_DATE)})`;
        }

        // Compression utilities
        function compressData(obj) {
            // Use ASN.1 UPER encoding
            const binary = encodeWebRTCData(obj);
            console.log('ASN.1 UPER encoded to', binary.length, 'bytes');
            
            // Add CRC for error detection
            const binaryWithCRC = addCRC(binary);
            console.log('Added CRC, total size:', binaryWithCRC.length, 'bytes');
            
            // Convert binary to string for QR code
            // Using Latin-1 encoding to preserve all byte values
            let binaryStr = '';
            for (let i = 0; i < binaryWithCRC.length; i++) {
                binaryStr += String.fromCharCode(binaryWithCRC[i]);
            }
            return btoa(binaryStr); // Base64 for safe transport
        }

        function decompressData(str) {
            try {
                console.log('Decompressing string:', str.substring(0, 50) + '...');
                console.log('String length:', str.length);
                
                // Check if string is empty or invalid
                if (!str || str.length === 0) {
                    console.error('Empty QR data received');
                    return null;
                }
                
                // Decode from Base64
                let binaryStr;
                try {
                    binaryStr = atob(str);
                } catch (e) {
                    console.error('Base64 decode error:', e);
                    console.error('Invalid base64 string:', str);
                    return null;
                }
                
                const bytesWithCRC = new Uint8Array(binaryStr.length);
                for (let i = 0; i < binaryStr.length; i++) {
                    bytesWithCRC[i] = binaryStr.charCodeAt(i);
                }
                console.log('Decoded to', bytesWithCRC.length, 'bytes (including CRC)');
                
                // Verify CRC
                const crcResult = verifyCRC(bytesWithCRC);
                if (!crcResult.valid) {
                    console.error('âŒ CRC check failed! Data is corrupted');
                    updateStatus('QR code corrupted! Please try again', 'error');
                    return null;
                }
                console.log('âœ… CRC check passed');
                
                const bytes = crcResult.data;
                console.log('Data size after CRC removal:', bytes.length, 'bytes');
                console.log('First 10 bytes:', Array.from(bytes.slice(0, 10)));
                
                // Decode ASN.1 UPER format
                const decoded = decodeWebRTCData(bytes);
                console.log('ASN.1 UPER decoded:', decoded);
                
                return decoded;
            } catch (error) {
                console.error('Decompression error:', error);
                console.error('Error stack:', error.stack);
                return null;
            }
        }

        // Extract only essential SDP data (including bundled ICE candidates)
        function minimizeSDP(sdp) {
            const lines = sdp.split('\n');
            const essential = [];
            
            lines.forEach(line => {
                // Keep only essential lines
                if (line.startsWith('v=') || 
                    line.startsWith('o=') ||
                    line.startsWith('s=') ||
                    line.startsWith('t=') ||
                    line.startsWith('a=group:') ||
                    line.startsWith('a=msid-semantic:') ||
                    line.startsWith('m=') ||
                    line.includes('a=ice-ufrag:') ||
                    line.includes('a=ice-pwd:') ||
                    line.includes('a=fingerprint:') ||
                    line.includes('a=setup:') ||
                    line.includes('a=mid:') ||
                    line.includes('a=sendrecv') ||
                    line.includes('a=rtcp-mux') ||
                    line.includes('a=candidate:') ||
                    line.includes('a=end-of-candidates')) {
                    essential.push(line);
                }
            });
            
            return essential.join('\n');
        }

        function showStep(step) {
            document.querySelectorAll('.step-view').forEach(el => el.classList.add('hidden'));
            document.getElementById(`step-${step}`).classList.remove('hidden');
        }

        function updateStatus(msg, type = 'info') {
            const el = document.getElementById('status');
            el.textContent = msg;
            const colorClasses = 
                type === 'error' ? 'bg-red-50 text-red-800' :
                type === 'success' ? 'bg-green-50 text-green-800' :
                'bg-blue-50 text-blue-800';
            el.className = 'mb-4 p-3 rounded-lg text-center ' + colorClasses;
        }

        async function startDevice1() {
            state.role = 'device1';
            updateStatus('Creating connection...');
            
            try {
                state.pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                // Add connection state monitoring
                state.pc.onconnectionstatechange = () => {
                    console.log('Connection state:', state.pc.connectionState);
                    updateStatus(`Connection: ${state.pc.connectionState}`);
                };
                
                state.pc.oniceconnectionstatechange = () => {
                    console.log('ICE connection state:', state.pc.iceConnectionState);
                };
                
                // Log ICE candidates as they are gathered
                state.pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const cand = event.candidate;
                        console.log('ICE candidate gathered:', {
                            type: cand.type,
                            address: cand.address,
                            port: cand.port,
                            protocol: cand.protocol,
                            candidateType: cand.candidateType
                        });
                    }
                };
                
                state.dc = state.pc.createDataChannel('chat', {
                    ordered: true,
                    maxRetransmits: 3
                });
                setupDataChannel();
                
                // Create offer
                const offer = await state.pc.createOffer();
                await state.pc.setLocalDescription(offer);
                
                // Wait for ICE gathering to complete
                await new Promise((resolve) => {
                    if (state.pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        state.pc.onicegatheringstatechange = () => {
                            if (state.pc.iceGatheringState === 'complete') {
                                resolve();
                            }
                        };
                        setTimeout(resolve, 3000); // Max 3 seconds
                    }
                });
                
                // Create ultra-compact offer data
                const offerData = {
                    t: 'o', // type: offer
                    ...compactSDP(state.pc.localDescription.sdp)
                };
                
                // Store for stats
                state.lastData = offerData;
                console.log('Offer data:', offerData);
                console.log('Offer type check: t =', offerData.t, '(should be "o")');
                console.log('Fingerprint length:', offerData.f ? offerData.f.length : 0);
                
                // Debug candidates
                if (offerData.c && offerData.c.length > 0) {
                    console.log('Candidates:');
                    offerData.c.forEach((cand, idx) => {
                        console.log(`  ${idx}: ${cand}`);
                        const parts = cand.split(',');
                        if (parts[1]) {
                            const [ip, port] = parts[1].split(':');
                            console.log(`    IP: ${ip}, Port: ${port}, Port int: ${parseInt(port)}`);
                        }
                    });
                }
                
                // Compress and show
                const compressed = compressData(offerData);
                console.log('Compressed offer:', compressed);
                console.log('Compressed length:', compressed.length);
                
                // Store current QR data for self-scan prevention
                state.currentQRData = compressed;
                
                // Test decode immediately
                const testDecode = decompressData(compressed);
                console.log('Test decode result:', testDecode);
                console.log('Test decode type:', testDecode?.t);
                
                // Debug decoded candidates
                if (testDecode?.c && testDecode.c.length > 0) {
                    console.log('Decoded candidates:');
                    testDecode.c.forEach((cand, idx) => {
                        console.log(`  ${idx}: ${cand}`);
                        const parts = cand.split(',');
                        if (parts[1]) {
                            const [ip, port] = parts[1].split(':');
                            console.log(`    IP: ${ip}, Port: ${port}, Port int: ${parseInt(port)}`);
                        }
                    });
                }
                
                showQR(compressed, 'Step 1: Show to Device 2');
                
            } catch (error) {
                updateStatus('Error: ' + error.message, 'error');
            }
        }

        async function processOffer(compressedData) {
            try {
                console.log('Processing compressed data:', compressedData);
                console.log('Compressed data length:', compressedData.length);
                
                const data = decompressData(compressedData);
                console.log('Decompressed offer data:', data);
                
                if (!data) {
                    throw new Error('Decompression failed - returned null');
                }
                if (data.t !== 'o') {
                    if (data.t === 'a') {
                        throw new Error('Received an answer instead of offer. Make sure to click Device 1 first, then Device 2.');
                    }
                    throw new Error(`Invalid offer type: expected 'o', got '${data.t}'`);
                }
                
                updateStatus('Processing offer...');
                state.role = 'device2';
                
                state.pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                // Add connection state monitoring
                state.pc.onconnectionstatechange = () => {
                    console.log('Device 2 - Connection state:', state.pc.connectionState);
                    updateStatus(`Connection: ${state.pc.connectionState}`);
                    if (state.pc.connectionState === 'connected') {
                        console.log('WebRTC connected! Waiting for data channel...');
                    }
                };
                
                state.pc.oniceconnectionstatechange = () => {
                    console.log('Device 2 - ICE connection state:', state.pc.iceConnectionState);
                };
                
                // Log ICE candidates as they are gathered
                state.pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const cand = event.candidate;
                        console.log('Device 2 - ICE candidate gathered:', {
                            type: cand.type,
                            address: cand.address,
                            port: cand.port,
                            protocol: cand.protocol,
                            candidateType: cand.candidateType
                        });
                    }
                };
                
                state.pc.ondatachannel = (event) => {
                    console.log('Data channel received:', event.channel.label);
                    state.dc = event.channel;
                    setupDataChannel();
                };
                
                // Set remote description (expand from compact format)
                const expandedSDP = expandSDP(data, 'offer');
                console.log('Expanded SDP:', expandedSDP);
                
                // Check if the problematic line exists
                if (expandedSDP.includes('a=end-of-candidates')) {
                    console.error('WARNING: SDP contains end-of-candidates line!');
                }
                
                try {
                    await state.pc.setRemoteDescription({
                        type: 'offer',
                        sdp: expandedSDP
                    });
                } catch (sdpError) {
                    console.error('SDP Error:', sdpError);
                    console.error('Full SDP was:', expandedSDP);
                    throw sdpError;
                }
                
                // ICE candidates are now bundled in the SDP
                
                // Create answer
                const answer = await state.pc.createAnswer();
                await state.pc.setLocalDescription(answer);
                
                // Wait for ICE gathering to complete
                await new Promise((resolve) => {
                    if (state.pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        state.pc.onicegatheringstatechange = () => {
                            if (state.pc.iceGatheringState === 'complete') {
                                resolve();
                            }
                        };
                        setTimeout(resolve, 3000);
                    }
                });
                
                // Log the actual SDP before compacting
                console.log('Device 2 answer SDP:', state.pc.localDescription.sdp);
                
                // Create ultra-compact answer data
                const answerData = {
                    t: 'a', // type: answer
                    ...compactSDP(state.pc.localDescription.sdp)
                };
                
                console.log('Creating answer data:', answerData);
                console.log('Answer type:', answerData.t);
                console.log('Answer candidates:', answerData.c);
                if (answerData.c) {
                    answerData.c.forEach((cand, idx) => {
                        console.log(`  Answer candidate ${idx}: ${cand}`);
                    });
                }
                
                // Store for stats
                state.lastData = answerData;
                
                // Compress and show
                const compressed = compressData(answerData);
                // Store current QR data for self-scan prevention
                state.currentQRData = compressed;
                showQR(compressed, 'Step 2: Show to Device 1');
                
            } catch (error) {
                updateStatus('Error: ' + error.message, 'error');
            }
        }

        async function processAnswer(compressedData) {
            try {
                const data = decompressData(compressedData);
                if (!data || data.t !== 'a') throw new Error('Invalid answer');
                
                console.log('Processing answer:', data);
                updateStatus('Connecting...');
                
                // Set remote description (expand from compact format)
                const expandedSDP = expandSDP(data, 'answer');
                console.log('Answer SDP:', expandedSDP);
                
                await state.pc.setRemoteDescription({
                    type: 'answer',
                    sdp: expandedSDP
                });
                
                console.log('Answer set successfully');
                console.log('Connection state after answer:', state.pc.connectionState);
                console.log('ICE state after answer:', state.pc.iceConnectionState);
                console.log('Data channel state:', state.dc?.readyState);
                
                // ICE candidates are now bundled in the SDP
                
            } catch (error) {
                console.error('processAnswer error:', error);
                updateStatus('Error: ' + error.message, 'error');
            }
        }
        
        async function processScannedOffer(compressedData) {
            try {
                const data = decompressData(compressedData);
                if (!data || data.t !== 'o') throw new Error('Invalid offer');
                
                // Log IP addresses for debugging
                if (data.c && data.c.length > 0) {
                    console.log('Decoded candidates from QR:');
                    data.c.forEach((candidate, idx) => {
                        console.log(`  Candidate ${idx + 1}: ${candidate}`);
                    });
                }
                
                console.log('Processing scanned offer (simultaneous mode):', data);
                updateStatus('Processing offer...');
                
                // Close existing peer connection if any
                if (state.pc) {
                    state.pc.close();
                }
                
                // Setup new peer connection
                state.pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                // Setup connection event handlers with reconnection support
                state.pc.oniceconnectionstatechange = () => {
                    console.log('ICE connection state:', state.pc.iceConnectionState);
                    const iceState = state.pc.iceConnectionState;
                    
                    if (iceState === 'connected' || iceState === 'completed') {
                        showStep('connected');
                        updateStatus('Connected!', 'success');
                        state.connectionEstablished = true;
                        // Store last known good connection data
                        state.lastOfferData = state.lastData;
                        // Run diagnostics after connection is established
                        setTimeout(() => {
                            runNetworkDiagnostics();
                        }, 1000); // Wait a bit for stats to be available
                    } else if (iceState === 'disconnected') {
                        updateStatus('Connection interrupted - attempting to reconnect...', 'warning');
                        // Give it a few seconds to recover naturally
                        setTimeout(() => {
                            if (state.pc && state.pc.iceConnectionState === 'disconnected') {
                                attemptReconnection();
                            }
                        }, 3000);
                    } else if (iceState === 'failed') {
                        updateStatus('Connection failed - attempting to reconnect...', 'error');
                        attemptReconnection();
                    }
                };
                
                // Set remote description
                const expandedSDP = expandSDP(data, 'offer');
                console.log('Setting remote description with expanded SDP');
                await state.pc.setRemoteDescription({
                    type: 'offer',
                    sdp: expandedSDP
                });
                console.log('Remote description set successfully');
                
                // Setup data channel handler for incoming channel
                state.pc.ondatachannel = (event) => {
                    console.log('Data channel received');
                    state.dc = event.channel;
                    setupDataChannel();
                };
                
                console.log('Creating answer...');
                // Create answer
                const answer = await state.pc.createAnswer();
                await state.pc.setLocalDescription(answer);
                
                // Wait for ICE gathering
                await new Promise((resolve) => {
                    if (state.pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        state.pc.onicegatheringstatechange = () => {
                            if (state.pc.iceGatheringState === 'complete') {
                                resolve();
                            }
                        };
                        setTimeout(resolve, 3000);
                    }
                });
                
                // Create answer data
                const answerData = {
                    t: 'a',
                    ...compactSDP(state.pc.localDescription.sdp)
                };
                
                // Update our QR to show the answer
                const compressed = compressData(answerData);
                // Store current QR data for self-scan prevention
                state.currentQRData = compressed;
                
                const qrDiv = document.getElementById('qr-display-split');
                qrDiv.innerHTML = '';
                new QRCode(qrDiv, {
                    text: compressed,
                    width: 240,
                    height: 240,
                    correctLevel: QRCode.CorrectLevel.L,
                    colorDark: '#ffffff',  // White QR code
                    colorLight: '#000000'  // Black background
                });
                
                // Update QR type label for answer
                const qrLabel = document.getElementById('qr-type-label');
                if (qrLabel) {
                    qrLabel.textContent = 'ðŸ“¥ Answer QR (Device 2)';
                    qrLabel.className = 'text-sm font-semibold text-green-400 mt-2';
                }
                
                // Debug: Show answer data
                console.log('Answer data for QR:', answerData);
                console.log('Answer candidates:', answerData.c);
                console.log('Compressed answer length:', compressed.length);
                
                // Update debug info panel
                const debugInfo = document.getElementById('qr-debug-info');
                const debugContent = document.getElementById('qr-debug-content');
                if (debugContent) {
                    let html = `<strong>Type:</strong> Answer<br>`;
                    html += `<strong>Compressed:</strong> ${compressed.length} chars<br>`;
                    html += `<strong>Fingerprint:</strong> ${answerData.f ? answerData.f.substring(0, 16) + '...' : 'N/A'}<br>`;
                    html += `<strong>Candidates:</strong> ${answerData.c ? answerData.c.length : 0}<br>`;
                    
                    if (answerData.c && answerData.c.length > 0) {
                        html += '<br><strong>Candidate details:</strong><br>';
                        answerData.c.forEach((c, i) => {
                            html += `${i + 1}: ${c}<br>`;
                        });
                    }
                    
                    debugContent.innerHTML = html;
                    if (debugInfo && state.debugMode) {
                        debugInfo.classList.remove('hidden');
                    }
                }
                
                updateStatus('Answer generated - show QR to other device');
                console.log('Device 2: Answer QR shown, camera should still be running for Device 1 to scan');
                
            } catch (error) {
                console.error('processScannedOffer error:', error);
                console.error('Error details:', error.stack || error.toString());
                updateStatus('Error: ' + (error.message || error.toString() || 'Unknown error'), 'error');
            }
        }

        function showQR(data, title) {
            document.getElementById('show-title').textContent = title;
            document.getElementById('data-text').value = data;
            
            // Calculate stats
            const originalJson = JSON.stringify({
                type: state.lastData.t === 'o' ? 'offer' : 'answer',
                sdp: 'v=0\no=- 1 1 IN IP4 127.0.0.1\ns=-\nt=0 0\n...(~1KB of SDP)...',
                candidates: ['candidate:...', 'candidate:...', 'candidate:...']
            });
            const binarySize = encodeWebRTCData(state.lastData || {}).length;
            const qrSize = data.length;
            const qrBits = Math.ceil(qrSize * 8); // Base64 uses 8 bits per char in QR
            
            document.getElementById('qr-size').textContent = `${qrSize} (${binarySize} bytes UPER)`;
            document.getElementById('compression-ratio').textContent = 
                Math.round((1 - qrBits / 7744) * 100); // vs original ~1KB
            
            // Generate QR
            const qrDiv = document.getElementById('qr-display');
            qrDiv.innerHTML = '';
            
            try {
                new QRCode(qrDiv, {
                    text: data,
                    width: 320,
                    height: 320,
                    correctLevel: QRCode.CorrectLevel.L,
                    colorDark: '#ffffff',  // White QR code
                    colorLight: '#000000'  // Black background
                });
            } catch (error) {
                // If QR is too big, show error
                qrDiv.innerHTML = '<p class="text-red-600">Data too large for QR. Use manual copy.</p>';
            }
            
            showStep('show');
            updateStatus(title);
            
            // Store QR data for split view if needed
            if (state.role === 'device1' && title.includes('Step 1')) {
                state.lastQRData = data;
            }
        }

        function setupDataChannel() {
            console.log('Setting up data channel, current state:', state.dc.readyState);
            
            state.dc.onopen = () => {
                console.log('Data channel opened!');
                showStep('connected');
                updateStatus('Connected!', 'success');
                stopCamera();
                
                // Initialize shared state
                initializeSharedState();
                
                // Exchange event histories after connection
                setTimeout(() => {
                    if (state.dc && state.dc.readyState === 'open') {
                        console.log('Sending event history to peer...');
                        state.dc.send(JSON.stringify({
                            type: 'eventHistory',
                            history: state.eventHistory,
                            role: state.role
                        }));
                    }
                }, 500);
            };
            
            state.dc.onclose = () => {
                console.log('Data channel closed');
                updateStatus('Disconnected', 'error');
            };
            
            state.dc.onmessage = (e) => {
                // Check if it's a shared state message
                if (e.data && typeof e.data === 'string' && e.data.startsWith('{"type":')) {
                    try {
                        const msg = JSON.parse(e.data);
                        handleSharedStateMessage(msg);
                    } catch (err) {
                        console.error('Error processing shared state message:', err);
                    }
                } else {
                    // Regular chat message
                    console.log('Message received:', e.data);
                    addMessage('Them', e.data);
                }
            };
            
            state.dc.onerror = (error) => {
                updateStatus('Connection error', 'error');
                console.error('DataChannel error:', error);
            };
            
            // Check if already open
            if (state.dc.readyState === 'open') {
                console.log('Data channel already open!');
                showStep('connected');
                updateStatus('Connected!', 'success');
                stopCamera();
                
                // Initialize shared state
                initializeSharedState();
                
                // Run network diagnostics
                runNetworkDiagnostics();
            }
        }
        
        function initializeSharedState() {
            console.log('Initializing shared state');
            
            // Request current state from peer
            if (state.role === 'device2' && state.dc && state.dc.readyState === 'open') {
                state.dc.send(JSON.stringify({ type: 'request-state' }));
            }
        }
        
        // Network Diagnostics Functions
        async function runNetworkDiagnostics() {
            console.log('Running network diagnostics...');
            
            if (!state.pc) {
                console.error('No peer connection available for diagnostics');
                return;
            }
            
            const diagnostics = {
                localCandidates: [],
                remoteCandidates: [],
                selectedPair: null,
                connectionType: 'Unknown',
                vpnDetected: false,
                sameLAN: false,
                networkTypes: {
                    local: 'Unknown',
                    remote: 'Unknown'
                },
                latency: null
            };
            
            try {
                // Get ICE candidates
                const stats = await state.pc.getStats();
                const candidates = {
                    local: [],
                    remote: []
                };
                
                stats.forEach(stat => {
                    if (stat.type === 'local-candidate') {
                        candidates.local.push(stat);
                    } else if (stat.type === 'remote-candidate') {
                        candidates.remote.push(stat);
                    } else if (stat.type === 'candidate-pair' && stat.state === 'succeeded') {
                        diagnostics.selectedPair = stat;
                    }
                });
                
                // Analyze local candidates
                candidates.local.forEach(candidate => {
                    const ip = candidate.address || candidate.ip;
                    if (ip) {
                        diagnostics.localCandidates.push({
                            ip: ip,
                            port: candidate.port,
                            protocol: candidate.protocol,
                            type: candidate.candidateType,
                            networkType: detectNetworkType(ip)
                        });
                    }
                });
                
                // Analyze remote candidates
                candidates.remote.forEach(candidate => {
                    const ip = candidate.address || candidate.ip;
                    if (ip) {
                        diagnostics.remoteCandidates.push({
                            ip: ip,
                            port: candidate.port,
                            protocol: candidate.protocol,
                            type: candidate.candidateType,
                            networkType: detectNetworkType(ip)
                        });
                    }
                });
                
                // Detect VPN
                diagnostics.vpnDetected = detectVPN(diagnostics.localCandidates);
                
                // Detect same LAN
                diagnostics.sameLAN = detectSameLAN(diagnostics.localCandidates, diagnostics.remoteCandidates);
                
                // Determine network types
                diagnostics.networkTypes.local = determineOverallNetworkType(diagnostics.localCandidates);
                diagnostics.networkTypes.remote = determineOverallNetworkType(diagnostics.remoteCandidates);
                
                // Get connection type from selected pair
                if (diagnostics.selectedPair) {
                    const localCandidate = candidates.local.find(c => c.id === diagnostics.selectedPair.localCandidateId);
                    const remoteCandidate = candidates.remote.find(c => c.id === diagnostics.selectedPair.remoteCandidateId);
                    
                    if (localCandidate && remoteCandidate) {
                        diagnostics.connectionType = getConnectionType(localCandidate, remoteCandidate);
                    }
                    
                    // Get latency if available
                    if (diagnostics.selectedPair.currentRoundTripTime) {
                        diagnostics.latency = Math.round(diagnostics.selectedPair.currentRoundTripTime * 1000);
                    }
                }
                
                // Update UI with diagnostics
                updateDiagnosticsUI(diagnostics);
                
            } catch (error) {
                console.error('Network diagnostics error:', error);
                document.getElementById('diagnostics-content').innerHTML = 
                    '<div class="text-red-600">Error running diagnostics</div>';
            }
        }
        
        function detectNetworkType(ip) {
            if (!ip) return 'Unknown';
            
            // Check for IPv6
            if (ip.includes(':')) {
                return 'IPv6';
            }
            
            // Parse IPv4
            const parts = ip.split('.');
            if (parts.length !== 4) return 'Unknown';
            
            const first = parseInt(parts[0]);
            const second = parseInt(parts[1]);
            
            // Localhost addresses
            if (ip === '127.0.0.1' || ip === '0.0.0.0') {
                return 'Localhost';
            }
            
            // Private networks
            if (first === 10) {
                return 'Private (10.x.x.x)';
            }
            if (first === 172 && second >= 16 && second <= 31) {
                return 'Private (172.16-31.x.x)';
            }
            if (first === 192 && second === 168) {
                return 'Private (192.168.x.x)';
            }
            
            // VPN/Special ranges
            if (first === 192 && second === 0 && parts[2] === '0') {
                return 'VPN/Special (192.0.0.x)';
            }
            
            // Carrier-grade NAT
            if (first === 100 && second >= 64 && second <= 127) {
                return 'Carrier NAT (100.64-127.x.x)';
            }
            
            // Link-local
            if (first === 169 && second === 254) {
                return 'Link-Local (169.254.x.x)';
            }
            
            return 'Public';
        }
        
        function detectVPN(candidates) {
            // Check for VPN indicators
            for (const candidate of candidates) {
                if (candidate.networkType === 'VPN/Special (192.0.0.x)') {
                    return true;
                }
                // Check for common VPN ranges
                if (candidate.ip && (
                    candidate.ip.startsWith('10.8.') ||  // OpenVPN default
                    candidate.ip.startsWith('10.9.') ||  // OpenVPN
                    candidate.ip.startsWith('172.27.') || // Some VPNs
                    candidate.ip.startsWith('172.28.') || // Some VPNs
                    candidate.ip.startsWith('172.29.') || // Some VPNs
                    candidate.ip.startsWith('172.30.') || // Some VPNs
                    candidate.ip.startsWith('172.31.')    // Some VPNs
                )) {
                    return true;
                }
            }
            return false;
        }
        
        function detectSameLAN(localCandidates, remoteCandidates) {
            // Check if any local and remote candidates share the same private network
            for (const local of localCandidates) {
                for (const remote of remoteCandidates) {
                    if (local.ip && remote.ip && 
                        local.networkType.includes('Private') && 
                        remote.networkType.includes('Private')) {
                        
                        // Check if same subnet
                        const localParts = local.ip.split('.');
                        const remoteParts = remote.ip.split('.');
                        
                        if (localParts[0] === remoteParts[0] && 
                            localParts[1] === remoteParts[1] && 
                            localParts[2] === remoteParts[2]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function determineOverallNetworkType(candidates) {
            // Determine if connection is cellular, WiFi, or wired based on candidates
            const hasPublic = candidates.some(c => c.networkType === 'Public');
            const hasCarrierNAT = candidates.some(c => c.networkType.includes('Carrier NAT'));
            const hasPrivate = candidates.some(c => c.networkType.includes('Private'));
            const hasIPv6 = candidates.some(c => c.networkType === 'IPv6');
            
            if (hasCarrierNAT) {
                return 'Cellular (Carrier NAT)';
            } else if (hasPublic && !hasPrivate) {
                return 'Direct Internet (No NAT)';
            } else if (hasPrivate) {
                return 'WiFi/Ethernet (NAT)';
            } else if (hasIPv6) {
                return 'IPv6 Network';
            }
            
            return 'Unknown';
        }
        
        function getConnectionType(localCandidate, remoteCandidate) {
            const localType = localCandidate.candidateType;
            const remoteType = remoteCandidate.candidateType;
            
            if (localType === 'host' && remoteType === 'host') {
                return 'Direct (P2P)';
            } else if (localType === 'srflx' || remoteType === 'srflx') {
                return 'STUN (NAT traversal)';
            } else if (localType === 'relay' || remoteType === 'relay') {
                return 'TURN (Relayed)';
            }
            
            return `${localType} â†” ${remoteType}`;
        }
        
        function updateDiagnosticsUI(diagnostics) {
            const content = document.getElementById('diagnostics-content');
            
            let html = '';
            
            // Connection type and latency
            html += `<div class="flex justify-between">
                <span class="text-gray-400">Connection Type:</span>
                <span class="font-medium">${diagnostics.connectionType}</span>
            </div>`;
            
            if (diagnostics.latency !== null) {
                html += `<div class="flex justify-between">
                    <span class="text-gray-400">Latency:</span>
                    <span class="font-medium">${diagnostics.latency}ms</span>
                </div>`;
            }
            
            // Network types
            html += `<div class="flex justify-between">
                <span class="text-gray-400">Your Network:</span>
                <span class="font-medium">${diagnostics.networkTypes.local}</span>
            </div>`;
            
            html += `<div class="flex justify-between">
                <span class="text-gray-400">Their Network:</span>
                <span class="font-medium">${diagnostics.networkTypes.remote}</span>
            </div>`;
            
            // VPN detection
            if (diagnostics.vpnDetected) {
                html += `<div class="flex justify-between">
                    <span class="text-gray-400">VPN Detected:</span>
                    <span class="font-medium text-orange-600">Yes</span>
                </div>`;
            }
            
            // Same LAN
            if (diagnostics.sameLAN) {
                html += `<div class="flex justify-between">
                    <span class="text-gray-400">Same Network:</span>
                    <span class="font-medium text-green-600">Yes (LAN)</span>
                </div>`;
            }
            
            // Local IPs
            if (diagnostics.localCandidates.length > 0) {
                const uniqueIPs = [...new Set(diagnostics.localCandidates.map(c => c.ip))].filter(ip => ip);
                html += `<div class="mt-2 pt-2 border-t border-gray-200">
                    <div class="text-gray-400 mb-1">Your IPs:</div>
                    ${uniqueIPs.map(ip => `<div class="ml-2 text-xs">${ip}</div>`).join('')}
                </div>`;
            }
            
            // Remote IPs
            if (diagnostics.remoteCandidates.length > 0) {
                const uniqueIPs = [...new Set(diagnostics.remoteCandidates.map(c => c.ip))].filter(ip => ip);
                html += `<div class="mt-2 pt-2 border-t border-gray-200">
                    <div class="text-gray-400 mb-1">Their IPs:</div>
                    ${uniqueIPs.map(ip => `<div class="ml-2 text-xs">${ip}</div>`).join('')}
                </div>`;
            }
            
            content.innerHTML = html;
        }
        
        function handleSharedStateMessage(msg) {
            switch (msg.type) {
                case 'eventHistory':
                    // Receive peer's event history
                    console.log('Received peer event history');
                    state.peerEventHistory = msg.history;
                    state.peerRole = msg.role;
                    consolidateEventHistories();
                    break;
                    
                case 'request-state':
                    // Send current state to peer
                    if (state.dc && state.dc.readyState === 'open') {
                        state.dc.send(JSON.stringify({
                            type: 'state-sync',
                            state: sharedState
                        }));
                    }
                    break;
                    
                case 'state-sync':
                    // Receive full state from peer
                    sharedState = msg.state;
                    redrawCanvas();
                    break;
                    
                case 'add-stroke':
                    // Add a new stroke
                    sharedState.canvas.strokes.push(msg.stroke);
                    sharedState.lastUpdate = Date.now();
                    redrawCanvas();
                    break;
                    
                case 'clear-canvas':
                    // Clear the canvas
                    sharedState.canvas.strokes = [];
                    sharedState.lastUpdate = Date.now();
                    redrawCanvas();
                    break;
            }
        }

        function addMessage(sender, text) {
            const el = document.getElementById('messages');
            const msg = document.createElement('div');
            msg.className = sender === 'You' ? 'text-right mb-1' : 'text-left mb-1';
            msg.innerHTML = `<span class="font-semibold">${sender}:</span> ${text}`;
            el.appendChild(msg);
            el.scrollTop = el.scrollHeight;
        }

        async function startScanner() {
            try {
                // Use selected camera (default to selfie cam for easier scanning)
                state.stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: state.cameraFacing }
                });
                
                const video = document.getElementById('video');
                video.srcObject = state.stream;
                
                // Simple canvas setup
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                
                let lastScanTime = 0;
                let noQRCount = 0;
                const SCAN_THROTTLE_MIN = 100;
                const SCAN_THROTTLE_MAX = 500;
                
                const scan = async () => {
                    const now = Date.now();
                    const throttle = noQRCount > 5 ? SCAN_THROTTLE_MAX : SCAN_THROTTLE_MIN;
                    
                    if (now - lastScanTime < throttle) {
                        setTimeout(() => requestAnimationFrame(() => scan()), throttle - (now - lastScanTime));
                        return;
                    }
                    
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        lastScanTime = now;
                        
                        // Set canvas size
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        
                        // Draw video frame
                        ctx.drawImage(video, 0, 0);
                        
                        // Get image data
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        // Scan for QR - only inverted since we use white QR on black
                        const code = await new Promise(resolve => {
                            resolve(jsQR(imageData.data, imageData.width, imageData.height, {
                                inversionAttempts: 'invertFirst'
                            }));
                        })
                        
                        if (code) {
                            noQRCount = 0; // Reset counter
                            
                            // Check if this is our own QR code (self-scan prevention)
                            if (state.currentQRData && code.data === state.currentQRData) {
                                console.log('Ignoring self-scan in simple scanner');
                                return;
                            }
                            
                            stopCamera();
                            if (state.scanTarget === 'offer') {
                                processOffer(code.data);
                            } else {
                                processAnswer(code.data);
                            }
                            return;
                        } else {
                            noQRCount++;
                        }
                    }
                    if (state.stream) {
                        requestAnimationFrame(() => scan());
                    }
                };
                
                video.addEventListener('loadedmetadata', () => scan());
                
            } catch (error) {
                updateStatus('Camera error', 'error');
                showStep('manual');
            }
        }

        async function startScannerSplit() {
            try {
                console.log('startScannerSplit: Requesting camera access...');
                updateStatus('Requesting camera access...');
                
                // Use selected camera (default to selfie cam for easier scanning)
                state.stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: state.cameraFacing }
                });
                
                console.log('startScannerSplit: Camera access granted');
                updateStatus('Point cameras at each other');
                
                const video = document.getElementById('video-split');
                video.srcObject = state.stream;
                
                // Simple canvas setup - let the browser optimize
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                
                let scanning = false;
                let lastScanTime = 0;
                let noQRCount = 0;
                const SCAN_THROTTLE_MIN = 100; // Fast scanning when QR detected
                const SCAN_THROTTLE_MAX = 500; // Slow scanning when no QR
                
                const scan = async () => {
                    if (!state.stream || scanning) return;
                    
                    const now = Date.now();
                    // Adaptive throttle - scan slower when no QR detected
                    const throttle = noQRCount > 5 ? SCAN_THROTTLE_MAX : SCAN_THROTTLE_MIN;
                    
                    if (now - lastScanTime < throttle) {
                        setTimeout(() => requestAnimationFrame(() => scan()), throttle - (now - lastScanTime));
                        return;
                    }
                    
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        scanning = true;
                        lastScanTime = now;
                        
                        const perfStart = state.debugMode ? performance.now() : 0;
                        
                        // Set canvas size to match video
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        
                        // Draw video frame - browser will use GPU if available
                        ctx.drawImage(video, 0, 0);
                        
                        // Get image data
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        // Scan for QR code - only inverted since we use white QR on black
                        const code = await new Promise(resolve => {
                            resolve(jsQR(imageData.data, imageData.width, imageData.height, {
                                inversionAttempts: 'invertFirst'
                            }));
                        })
                        
                        if (code) {
                            noQRCount = 0; // Reset counter when QR found
                            
                            // Check if this is our own QR code (self-scan prevention)
                            if (state.currentQRData && code.data === state.currentQRData) {
                                console.log('Ignoring self-scan (detected our own QR code)');
                                scanning = false;
                                return;
                            }
                            
                            // Determine what type of data we scanned
                            const decompressed = decompressData(code.data);
                            if (decompressed) {
                                // Store the last processed QR to avoid duplicates
                                const qrKey = `${decompressed.t}-${code.data.substring(0, 20)}`;
                                if (state.processedQRs && state.processedQRs.has(qrKey)) {
                                    console.log('Already processed this QR, ignoring duplicate');
                                    scanning = false;
                                    return;
                                }
                                
                                // Initialize processed QRs set if needed
                                if (!state.processedQRs) {
                                    state.processedQRs = new Set();
                                }
                                state.processedQRs.add(qrKey);
                                
                                // Only stop camera if we're scanning an answer (final step)
                                // Keep camera running after scanning offer so Device 1 can scan our answer
                                if (decompressed.t === 'a') {
                                    stopCamera();
                                }
                                
                                if (decompressed.t === 'o') {
                                    // We scanned an offer - keep camera running for Device 1 to scan our answer
                                    processScannedOffer(code.data);
                                    // Don't return - let scanning continue
                                    scanning = false;
                                } else if (decompressed.t === 'a') {
                                    // We scanned an answer - connection complete
                                    processAnswer(code.data);
                                    scanning = false;
                                    return;
                                }
                            } else {
                                scanning = false;
                            }
                        } else {
                            noQRCount++; // Increment when no QR found
                        }
                        
                        // Log performance in debug mode
                        if (state.debugMode && perfStart) {
                            const elapsed = performance.now() - perfStart;
                            if (elapsed > 16) { // Only log if over 1 frame (16ms)
                                console.log(`Scan took ${elapsed.toFixed(1)}ms (throttle: ${noQRCount > 5 ? 'slow' : 'fast'})`);
                            }
                        }
                        
                        scanning = false;
                    }
                    if (state.stream) {
                        requestAnimationFrame(() => scan());
                    }
                };
                
                video.addEventListener('loadedmetadata', () => scan());
                
            } catch (error) {
                console.error('Split scanner error:', error);
                updateStatus(`Camera error: ${error.message}`, 'error');
                
                // Add click-to-retry functionality
                document.getElementById('status').onclick = () => {
                    location.reload();
                };
                document.getElementById('status').style.cursor = 'pointer';
            }
        }

        function stopCamera() {
            console.log('stopCamera called - current state:', {
                role: state.role,
                hasStream: !!state.stream,
                connectionState: state.pc?.connectionState
            });
            if (state.stream) {
                state.stream.getTracks().forEach(t => {
                    console.log('Stopping track:', t.kind, t.label);
                    t.stop();
                });
                state.stream = null;
            }
        }
        
        // Reconnection logic for network changes
        async function attemptReconnection() {
            if (state.reconnecting) return; // Avoid multiple reconnection attempts
            state.reconnecting = true;
            
            console.log('Attempting to reconnect...');
            updateStatus('Reconnecting...', 'warning');
            
            try {
                // Close existing connection
                if (state.pc) {
                    state.pc.close();
                }
                
                // If we have stored connection data, try to re-establish
                if (state.lastOfferData || state.preGeneratedOffer) {
                    // Restart the unified flow
                    await startUnified('auto');
                } else {
                    // No stored data, need to reload
                    updateStatus('Connection lost - click to reload', 'error');
                    document.getElementById('status').onclick = () => {
                        location.reload();
                    };
                    document.getElementById('status').style.cursor = 'pointer';
                }
            } catch (error) {
                console.error('Reconnection failed:', error);
                updateStatus('Reconnection failed - click to reload', 'error');
                document.getElementById('status').onclick = () => {
                    location.reload();
                };
                document.getElementById('status').style.cursor = 'pointer';
            } finally {
                state.reconnecting = false;
            }
        }

        // New unified start function for both devices
        async function startUnified(deviceRole) {
            state.role = deviceRole;
            updateStatus('Creating offer...');
            
            try {
                // Always create an offer (both devices)
                state.pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                // Setup connection event handlers with reconnection support
                state.pc.oniceconnectionstatechange = () => {
                    console.log('ICE connection state:', state.pc.iceConnectionState);
                    const iceState = state.pc.iceConnectionState;
                    
                    if (iceState === 'connected' || iceState === 'completed') {
                        showStep('connected');
                        updateStatus('Connected!', 'success');
                        state.connectionEstablished = true;
                        // Store last known good connection data
                        state.lastOfferData = state.lastData;
                        // Run diagnostics after connection is established
                        setTimeout(() => {
                            runNetworkDiagnostics();
                        }, 1000); // Wait a bit for stats to be available
                    } else if (iceState === 'disconnected') {
                        updateStatus('Connection interrupted - attempting to reconnect...', 'warning');
                        // Give it a few seconds to recover naturally
                        setTimeout(() => {
                            if (state.pc && state.pc.iceConnectionState === 'disconnected') {
                                attemptReconnection();
                            }
                        }, 3000);
                    } else if (iceState === 'failed') {
                        updateStatus('Connection failed - attempting to reconnect...', 'error');
                        attemptReconnection();
                    }
                };
                
                // Create data channel
                state.dc = state.pc.createDataChannel('data', {
                    ordered: true,
                    maxRetransmits: 3
                });
                setupDataChannel();
                
                // Create offer
                const offer = await state.pc.createOffer();
                await state.pc.setLocalDescription(offer);
                
                // Wait for ICE gathering
                await new Promise((resolve) => {
                    if (state.pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        state.pc.onicegatheringstatechange = () => {
                            if (state.pc.iceGatheringState === 'complete') {
                                resolve();
                            }
                        };
                        setTimeout(resolve, 3000);
                    }
                });
                
                // Create offer data
                const offerData = {
                    t: 'o',
                    ...compactSDP(state.pc.localDescription.sdp)
                };
                
                state.lastData = offerData;
                const compressed = compressData(offerData);
                state.lastQRData = compressed;
                // Store for self-scan prevention
                state.currentQRData = compressed;
                
                // Show split view with QR and camera
                const qrDiv = document.getElementById('qr-display-split');
                qrDiv.innerHTML = '';
                new QRCode(qrDiv, {
                    text: compressed,
                    width: 240,
                    height: 240,
                    correctLevel: QRCode.CorrectLevel.L,
                    colorDark: '#ffffff',  // White QR code
                    colorLight: '#000000'  // Black background
                });
                
                // Update QR type label for offer
                const qrLabel = document.getElementById('qr-type-label');
                if (qrLabel) {
                    qrLabel.textContent = 'ðŸ“¤ Offer QR (Device 1)';
                    qrLabel.className = 'text-sm font-semibold text-gray-400 mt-2';
                }
                
                // Debug: Show offer data
                console.log('Offer data for QR:', offerData);
                console.log('Offer candidates:', offerData.c);
                console.log('Compressed offer length:', compressed.length);
                
                // Update debug info panel
                const debugInfo = document.getElementById('qr-debug-info');
                const debugContent = document.getElementById('qr-debug-content');
                if (debugContent) {
                    let html = `<strong>Type:</strong> Offer<br>`;
                    html += `<strong>Compressed:</strong> ${compressed.length} chars<br>`;
                    html += `<strong>Fingerprint:</strong> ${offerData.f ? offerData.f.substring(0, 16) + '...' : 'N/A'}<br>`;
                    html += `<strong>Candidates:</strong> ${offerData.c ? offerData.c.length : 0}<br>`;
                    
                    if (offerData.c && offerData.c.length > 0) {
                        html += '<br><strong>Candidate details:</strong><br>';
                        offerData.c.forEach((c, i) => {
                            html += `${i + 1}: ${c}<br>`;
                        });
                    }
                    
                    debugContent.innerHTML = html;
                    if (debugInfo && state.debugMode) {
                        debugInfo.classList.remove('hidden');
                    }
                }
                
                // Set scan target based on role
                state.scanTarget = 'both'; // Accept both offers and answers
                showStep('device1-split');
                startScannerSplit();
                updateStatus('Point cameras at each other');
                
            } catch (error) {
                console.error('Failed to create offer:', error);
                updateStatus('Error: ' + error.message, 'error');
            }
        }
        
        // Event listeners - removed device buttons since we auto-start
        // Helper function to safely add event listeners
        const addClickHandler = (id, handler) => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('click', handler);
            }
        };
        
        addClickHandler('manual-btn', () => {
            stopCamera();
            showStep('manual');
        });
        
        addClickHandler('process-btn', () => {
            const data = document.getElementById('manual-input').value.trim();
            if (data) {
                if (state.scanTarget === 'offer') {
                    processOffer(data);
                } else {
                    processAnswer(data);
                }
            }
        });
        
        addClickHandler('back-scan-btn', () => {
            document.getElementById('manual-input').value = '';
            showStep('scan');
            startScanner();
        });
        
        addClickHandler('send-btn', () => {
            const input = document.getElementById('msg-input');
            if (input.value && state.dc?.readyState === 'open') {
                state.dc.send(input.value);
                addMessage('You', input.value);
                input.value = '';
            }
        });
        
        const msgInput = document.getElementById('msg-input');
        if (msgInput) {
            msgInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const sendBtn = document.getElementById('send-btn');
                    if (sendBtn) sendBtn.click();
                }
            });
        }
        
        // Pre-generate offer on load for instant QR display
        async function preGenerateOffer() {
            try {
                console.log('Pre-generating offer...');
                const pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                const dc = pc.createDataChannel('data');
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                // Wait for ICE gathering
                await new Promise((resolve) => {
                    if (pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        pc.addEventListener('icegatheringstatechange', () => {
                            if (pc.iceGatheringState === 'complete') resolve();
                        });
                        setTimeout(resolve, 3000); // Max 3 seconds
                    }
                });
                
                // Create compact offer data
                const offerData = {
                    t: 'o',
                    ...compactSDP(pc.localDescription.sdp)
                };
                
                console.log('Pre-generation: offerData candidates:', offerData.c ? offerData.c.length : 0);
                if (offerData.c) {
                    offerData.c.forEach((cand, idx) => {
                        console.log(`  Pre-gen candidate ${idx + 1}: ${cand}`);
                    });
                }
                
                // Compress and store
                state.preGeneratedOffer = offerData;
                state.preGeneratedQR = compressData(offerData);
                
                // Clean up
                pc.close();
                
                console.log('Pre-generated QR ready:', state.preGeneratedQR.length, 'chars');
            } catch (error) {
                console.error('Pre-generation failed:', error);
            }
        }
        
        // Pre-generate on load
        preGenerateOffer();
        
        // Auto-start immediately
        async function autoStart() {
            // Wait a bit longer for everything to initialize
            setTimeout(async () => {
                try {
                    console.log('Auto-starting Pair2Peer...');
                    await startUnified('auto');
                } catch (error) {
                    console.error('Auto-start failed:', error);
                    updateStatus('Camera permission needed - click to retry', 'error');
                    // Show a retry button on error
                    document.getElementById('status').onclick = () => {
                        location.reload();
                    };
                    document.getElementById('status').style.cursor = 'pointer';
                }
            }, 500);
        }
        
        // Check if DOM is already loaded (common in modules)
        if (document.readyState === 'loading') {
            window.addEventListener('DOMContentLoaded', autoStart);
        } else {
            // DOM is already loaded
            autoStart();
        }
        
        // Monitor network changes
        window.addEventListener('online', () => {
            console.log('Network connection restored');
            if (state.connectionEstablished && state.pc && 
                (state.pc.iceConnectionState === 'disconnected' || state.pc.iceConnectionState === 'failed')) {
                attemptReconnection();
            }
        });
        
        window.addEventListener('offline', () => {
            console.log('Network connection lost');
            updateStatus('Network offline', 'error');
        });
        
        // Self-test function
        async function runSelfTest() {
            console.log('=== RUNNING SELF TEST ===');
            updateStatus('Running self test...', 'info');
            
            try {
                // Wait for pre-generation to complete if not ready
                if (!state.preGeneratedOffer || !state.preGeneratedQR) {
                    console.log('Waiting for pre-generation to complete...');
                    let waitCount = 0;
                    while ((!state.preGeneratedOffer || !state.preGeneratedQR) && waitCount < 50) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        waitCount++;
                    }
                    
                    if (!state.preGeneratedOffer || !state.preGeneratedQR) {
                        console.log('Pre-generation did not complete in time, running it now...');
                        await preGenerateOffer();
                    }
                }
                
                // Test 1: Use the ACTUAL pre-generated offer
                if (state.preGeneratedOffer && state.preGeneratedQR) {
                    console.log('\n--- TEST 1: Real WebRTC Offer ---');
                    console.log('Using actual pre-generated offer');
                    console.log('Original offer:', state.preGeneratedOffer);
                    console.log('Original offer candidates count:', state.preGeneratedOffer.c ? state.preGeneratedOffer.c.length : 0);
                    if (state.preGeneratedOffer.c) {
                        state.preGeneratedOffer.c.forEach((cand, idx) => {
                            console.log(`  Candidate ${idx + 1}: ${cand}`);
                        });
                    }
                    console.log('Compressed QR:', state.preGeneratedQR);
                    console.log('QR length:', state.preGeneratedQR.length, 'characters');
                    
                    // Simulate what Device 2 would do
                    const simulatedScan = state.preGeneratedQR;
                    console.log('Simulating QR scan of:', simulatedScan.substring(0, 50) + '...');
                    
                    // Log the binary data
                    const binaryStr = atob(simulatedScan);
                    const bytes = new Uint8Array(binaryStr.length);
                    for (let i = 0; i < binaryStr.length; i++) {
                        bytes[i] = binaryStr.charCodeAt(i);
                    }
                    console.log('Binary data length:', bytes.length, 'bytes');
                    console.log('Binary hex:', Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' '));
                    
                    const decoded = decompressData(simulatedScan);
                    console.log('Decoded result:', decoded);
                    console.log('Decoded candidates count:', decoded?.c?.length);
                    
                    if (!decoded) {
                        console.error('âŒ REAL DATA TEST FAILED: Decompression returned null');
                        updateStatus('Self test failed: Real data decompression failed', 'error');
                        return;
                    }
                    
                    if (decoded.t !== 'o') {
                        console.error(`âŒ REAL DATA TEST FAILED: Expected type 'o', got '${decoded.t}'`);
                        updateStatus(`Self test failed: Wrong type ${decoded.t}`, 'error');
                        return;
                    }
                    
                    // Verify all fields match
                    console.log('Comparing fields:');
                    console.log('Type match:', decoded.t === state.preGeneratedOffer.t);
                    console.log('Ufrag match:', decoded.u === state.preGeneratedOffer.u);
                    console.log('Pwd match:', decoded.p === state.preGeneratedOffer.p);
                    console.log('Setup match:', decoded.s === state.preGeneratedOffer.s);
                    console.log('Fingerprint match:', decoded.f === state.preGeneratedOffer.f);
                    console.log('Candidates match:', JSON.stringify(decoded.c) === JSON.stringify(state.preGeneratedOffer.c));
                    
                    // Test SDP expansion
                    try {
                        const expandedSDP = expandSDP(decoded, 'offer');
                        console.log('Expanded SDP length:', expandedSDP.length);
                        console.log('SDP preview:', expandedSDP.substring(0, 200) + '...');
                        
                        // Check for the problematic line from the error
                        const lines = expandedSDP.split(/\r\n|\r|\n/);
                        const candidateLines = lines.filter(l => l.startsWith('a=candidate:'));
                        console.log('Number of candidate lines:', candidateLines.length);
                        console.log('Candidate lines:', candidateLines);
                        
                        // Check for known problematic lines
                        const problematicLines = lines.filter(line => 
                            line.includes('a=end-of-candidates')
                        );
                        if (problematicLines.length > 0) {
                            console.error('âŒ Found problematic SDP lines:', problematicLines);
                        }
                        
                        // Validate each candidate
                        let hasInvalidPort = false;
                        candidateLines.forEach((line, idx) => {
                            const portMatch = line.match(/ (\d+) typ /);
                            if (portMatch) {
                                const port = parseInt(portMatch[1]);
                                console.log(`Candidate ${idx + 1} port: ${port}`);
                                if (port < 1 || port > 65535) {
                                    console.error(`âŒ Invalid port number: ${port}`);
                                    hasInvalidPort = true;
                                }
                            }
                        });
                        
                        if (hasInvalidPort) {
                            console.error('âŒ REAL DATA TEST FAILED: Invalid port numbers detected');
                            updateStatus('Self test failed: Invalid port numbers', 'error');
                            return;
                        }
                        
                        // CRITICAL: Test actual browser SDP parsing
                        console.log('\nTesting browser SDP parsing...');
                        const testPc = new RTCPeerConnection();
                        try {
                            await testPc.setRemoteDescription({
                                type: 'offer',
                                sdp: expandedSDP
                            });
                            console.log('âœ… Browser successfully parsed the SDP');
                            testPc.close();
                        } catch (browserError) {
                            console.error('âŒ BROWSER SDP PARSING FAILED:', browserError);
                            console.error('Failed SDP was:', expandedSDP);
                            testPc.close();
                            updateStatus('Self test failed: Browser cannot parse SDP', 'error');
                            return;
                        }
                        
                        console.log('âœ… REAL DATA TEST PASSED');
                    } catch (sdpError) {
                        console.error('âŒ SDP expansion failed:', sdpError);
                        updateStatus('Self test failed: SDP expansion error', 'error');
                        return;
                    }
                } else {
                    console.log('âŒ Real data test: Skipped (no data available)');
                }
                
                // Test 2: Simple known data
                console.log('\n--- TEST 2: Simple Known Data ---');
                const testData = {
                    t: 'o',
                    u: 'TEST',
                    p: 'TestPassword123456789012',
                    f: '01:23:45:67:89:AB:CD:EF:01:23:45:67:89:AB:CD:EF:01:23:45:67:89:AB:CD:EF:01:23:45:67:89:AB:CD:EF',
                    s: 'a',
                    c: ['h,192.168.1.100:12345,1', 's,10.0.0.1:54321,203.0.113.1:3478,1']
                };
                
                console.log('Test data:', testData);
                
                // Compress it
                const compressed = compressData(testData);
                console.log('Compressed:', compressed);
                console.log('Compressed length:', compressed.length, 'chars');
                console.log('Binary size:', encodeWebRTCData(testData).length, 'bytes');
                
                // Decompress it
                const decompressed = decompressData(compressed);
                console.log('Decompressed:', decompressed);
                
                // Verify
                const expectedFingerprint = testData.f.toUpperCase();
                const actualFingerprint = decompressed ? decompressed.f : '';
                const fingerprintMatch = actualFingerprint === expectedFingerprint;
                
                console.log('Fingerprint comparison:');
                console.log('Expected:', expectedFingerprint);
                console.log('Actual:', actualFingerprint);
                console.log('Match:', fingerprintMatch);
                
                const passed = 
                    decompressed && 
                    decompressed.t === testData.t &&
                    decompressed.u === testData.u &&
                    decompressed.p === testData.p &&
                    fingerprintMatch &&
                    decompressed.s === testData.s &&
                    JSON.stringify(decompressed.c) === JSON.stringify(testData.c);
                
                if (passed) {
                    console.log('âœ… SIMPLE DATA TEST PASSED');
                    
                    // Test SDP expansion
                    console.log('\nTesting SDP expansion...');
                    const expandedSDP = expandSDP(decompressed, 'offer');
                    console.log('Expanded SDP preview:', expandedSDP.substring(0, 200) + '...');
                    
                    if (expandedSDP.includes('v=0') && expandedSDP.includes('a=ice-ufrag:TEST')) {
                        console.log('âœ… SDP expansion working');
                        updateStatus('Self test passed! All tests successful.', 'success');
                    } else {
                        console.log('âŒ SDP expansion failed');
                        updateStatus('Self test failed: SDP expansion issue', 'error');
                    }
                } else {
                    console.log('âŒ SIMPLE DATA TEST FAILED');
                    console.log('Expected:', testData);
                    console.log('Got:', decompressed);
                    updateStatus('Self test failed! Check console for details.', 'error');
                }
                
                // Summary
                console.log('\n=== TEST SUMMARY ===');
                console.log('Real data test:', state.preGeneratedOffer ? 'Passed' : 'Skipped (no data)');
                console.log('Simple data test:', passed ? 'Passed' : 'Failed');
                
            } catch (error) {
                console.error('Self test error:', error);
                updateStatus('Self test error: ' + error.message, 'error');
            }
        }
        
        // Add event listeners for selftest buttons
        const setupSelfTest = (btnId) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', runSelfTest);
            }
        };
        
        setupSelfTest('selftest-btn');
        setupSelfTest('selftest-btn-split');
        
        // Refresh diagnostics button
        const refreshBtn = document.getElementById('refresh-diagnostics');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => {
                console.log('Refreshing network diagnostics...');
                runNetworkDiagnostics();
            });
        }
        
        // Debug toggle button (for both regular and split views)
        const setupDebugToggle = (toggleId, optionsId) => {
            const toggle = document.getElementById(toggleId);
            const options = document.getElementById(optionsId);
            if (toggle && options) {
                toggle.addEventListener('click', () => {
                    if (options.classList.contains('hidden')) {
                        options.classList.remove('hidden');
                        toggle.textContent = 'â–¼ Debug';
                    } else {
                        options.classList.add('hidden');
                        toggle.textContent = 'â–¶ Debug';
                    }
                });
            }
        };
        
        setupDebugToggle('debug-toggle', 'debug-options');
        setupDebugToggle('debug-toggle-split', 'debug-options-split');
        
        // Toggle console button (for both regular and split views)
        const setupConsoleToggle = (btnId) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => {
                    const panel = document.getElementById('debug-panel');
                    window.debugConsoleEnabled = !window.debugConsoleEnabled;
                    
                    if (window.debugConsoleEnabled) {
                        panel.classList.remove('hidden');
                    } else {
                        panel.classList.add('hidden');
                    }
                });
            }
        };
        
        setupConsoleToggle('toggle-console');
        setupConsoleToggle('toggle-console-split');
        
        // Camera switch button
        addClickHandler('switch-camera-btn', async () => {
            // Toggle camera facing
            state.cameraFacing = state.cameraFacing === 'user' ? 'environment' : 'user';
            console.log('Switching to', state.cameraFacing, 'camera');
            
            // Stop current stream
            if (state.stream) {
                state.stream.getTracks().forEach(track => track.stop());
            }
            
            // Restart scanner with new camera
            try {
                await startScanner();
                updateStatus(`Switched to ${state.cameraFacing === 'user' ? 'front' : 'back'} camera`, 'info');
            } catch (error) {
                console.error('Camera switch error:', error);
                updateStatus('Failed to switch camera', 'error');
                // Try to fall back to other camera
                state.cameraFacing = state.cameraFacing === 'user' ? 'environment' : 'user';
                await startScanner();
            }
        });

        // Camera switch button in split view
        addClickHandler('switch-camera-split', async () => {
            // Toggle camera facing
            state.cameraFacing = state.cameraFacing === 'user' ? 'environment' : 'user';
            console.log('Switching to', state.cameraFacing, 'camera in split view');
            
            // Stop current stream
            if (state.stream) {
                state.stream.getTracks().forEach(track => track.stop());
            }
            
            // Restart scanner with new camera
            try {
                await startScannerSplit();
                updateStatus(`Switched to ${state.cameraFacing === 'user' ? 'front' : 'back'} camera`, 'info');
            } catch (error) {
                console.error('Camera switch error:', error);
                updateStatus('Failed to switch camera', 'error');
                // Try to fall back to other camera
                state.cameraFacing = state.cameraFacing === 'user' ? 'environment' : 'user';
                await startScannerSplit();
            }
        });
        
        // Debug panel clear button
        addClickHandler('clear-debug', () => {
            window.debugLogs.length = 0;
            window.updateDebugPanel();
        });
        
        // Debug panel copy button
        addClickHandler('copy-debug', () => {
            const logText = window.debugLogs.map(log => 
                `[${log.timestamp}] ${log.message}`
            ).join('\n');
            
            navigator.clipboard.writeText(logText).then(() => {
                // Briefly change button text to show success
                const copyBtn = document.getElementById('copy-debug');
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                }, 1500);
            }).catch(err => {
                console.error('Failed to copy logs:', err);
            });
        });
        
        // Function to consolidate event histories from both devices
        function consolidateEventHistories() {
            if (!state.eventHistory || !state.peerEventHistory) {
                console.log('Cannot consolidate - missing event history');
                return;
            }
            
            console.log('Consolidating event histories...');
            
            // Combine both histories
            const allEvents = [
                ...state.eventHistory.map(e => ({...e, device: state.role})),
                ...state.peerEventHistory.map(e => ({...e, device: state.peerRole}))
            ];
            
            // Sort by timestamp
            allEvents.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // Create unified narrative
            console.log('\n=== UNIFIED CONNECTION TIMELINE ===');
            console.log(`Device 1: ${state.role === 'device1' ? 'This device' : 'Peer device'}`);
            console.log(`Device 2: ${state.role === 'device2' ? 'This device' : 'Peer device'}`);
            console.log('\nTimeline:');
            
            let lastTime = null;
            allEvents.forEach((event, idx) => {
                const time = new Date(event.timestamp);
                const timeDiff = lastTime ? (time - lastTime) / 1000 : 0;
                lastTime = time;
                
                const prefix = event.device === 'device1' ? '[D1]' : '[D2]';
                const timeStr = time.toISOString().substring(11, 23);
                const deltaStr = idx > 0 ? ` (+${timeDiff.toFixed(2)}s)` : '';
                
                console.log(`${timeStr}${deltaStr} ${prefix} ${event.message}`);
                
                // Highlight significant events
                if (event.message.includes('ICE connection state: connected') ||
                    event.message.includes('Data channel opened') ||
                    event.message.includes('error') ||
                    event.message.includes('failed')) {
                    console.log(`  ^ ${event.connectionState ? `Connection: ${event.connectionState}` : ''} ${event.iceState ? `ICE: ${event.iceState}` : ''}`);
                }
            });
            
            console.log('\n=== END TIMELINE ===\n');
            
            // Store consolidated history
            state.consolidatedHistory = allEvents;
            
            // Show summary in UI
            const totalTime = (new Date(allEvents[allEvents.length - 1].timestamp) - new Date(allEvents[0].timestamp)) / 1000;
            updateStatus(`Connected! Total setup time: ${totalTime.toFixed(1)}s`, 'success');
            
            // Also show timeline in debug panel if enabled
            if (window.debugConsoleEnabled) {
                const summaryHtml = `
                    <div class="text-yellow-400 font-bold mt-2">Connection Timeline Summary:</div>
                    <div class="text-gray-300">Total setup time: ${totalTime.toFixed(1)}s</div>
                    <div class="text-gray-300">Events: ${allEvents.length}</div>
                    <div class="text-gray-300">Check console for full timeline</div>
                `;
                const content = document.getElementById('debug-content');
                if (content) {
                    content.innerHTML += summaryHtml;
                }
            }
        }
        
        // Tab switching
        addClickHandler('chat-tab', () => {
            document.getElementById('chat-tab').classList.add('border-gray-400', 'text-gray-400', 'font-semibold');
            document.getElementById('chat-tab').classList.remove('border-transparent');
            document.getElementById('canvas-tab').classList.remove('border-gray-400', 'text-gray-400', 'font-semibold');
            document.getElementById('canvas-tab').classList.add('border-transparent');
            
            document.getElementById('chat-view').classList.remove('hidden');
            document.getElementById('canvas-view').classList.add('hidden');
        });
        
        addClickHandler('canvas-tab', () => {
            document.getElementById('canvas-tab').classList.add('border-gray-400', 'text-gray-400', 'font-semibold');
            document.getElementById('canvas-tab').classList.remove('border-transparent');
            document.getElementById('chat-tab').classList.remove('border-gray-400', 'text-gray-400', 'font-semibold');
            document.getElementById('chat-tab').classList.add('border-transparent');
            
            document.getElementById('canvas-view').classList.remove('hidden');
            document.getElementById('chat-view').classList.add('hidden');
            
            // Initialize canvas if not done
            initCanvas();
        });
        
        // Canvas functionality
        let canvas, ctx;
        let isDrawing = false;
        let currentColor = '#000000';
        let currentStroke = null;
        
        function initCanvas() {
            if (canvas) return; // Already initialized
            
            canvas = document.getElementById('shared-canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size properly
            canvas.width = 400;
            canvas.height = 300;
            
            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', stopDrawing);
            
            // Color buttons
            document.querySelectorAll('[data-color]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    currentColor = e.target.dataset.color;
                    // Update border to show selection
                    document.querySelectorAll('[data-color]').forEach(b => {
                        b.classList.remove('border-gray-800');
                        b.classList.add('border-gray-300');
                    });
                    e.target.classList.remove('border-gray-300');
                    e.target.classList.add('border-gray-800');
                });
            });
            
            // Clear button
            addClickHandler('clear-canvas', () => {
                // Clear canvas and notify peer
                sharedState.canvas.strokes = [];
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (state.dc && state.dc.readyState === 'open') {
                    state.dc.send(JSON.stringify({ type: 'clear-canvas' }));
                }
            });
        }
        
        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (e.type === 'touchstart') {
                startDrawing({ offsetX: x, offsetY: y });
            } else if (e.type === 'touchmove') {
                draw({ offsetX: x, offsetY: y });
            }
        }
        
        function startDrawing(e) {
            isDrawing = true;
            currentStroke = {
                color: currentColor,
                points: [{ x: e.offsetX, y: e.offsetY }]
            };
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            const point = { x: e.offsetX, y: e.offsetY };
            currentStroke.points.push(point);
            
            // Draw locally immediately
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(currentStroke.points[currentStroke.points.length - 2].x, 
                       currentStroke.points[currentStroke.points.length - 2].y);
            ctx.lineTo(point.x, point.y);
            ctx.stroke();
        }
        
        function stopDrawing() {
            if (!isDrawing || !currentStroke) return;
            isDrawing = false;
            
            // Add stroke to shared state and notify peer
            sharedState.canvas.strokes.push(currentStroke);
            
            if (state.dc && state.dc.readyState === 'open') {
                state.dc.send(JSON.stringify({
                    type: 'add-stroke',
                    stroke: currentStroke
                }));
            }
            
            currentStroke = null;
        }
        
        function redrawCanvas() {
            if (!canvas || !ctx) return;
            
            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Redraw all strokes
            sharedState.canvas.strokes.forEach(stroke => {
                ctx.strokeStyle = stroke.color;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                
                stroke.points.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                
                ctx.stroke();
            });
        }
    </script>
</body>
</html>